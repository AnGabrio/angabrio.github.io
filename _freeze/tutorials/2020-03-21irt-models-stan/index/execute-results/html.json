{
  "hash": "81c3fc61ee79544988556548aabd7a15",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Item Response Theory Models (Stan)\"\ndescription: \"\"\nauthor:\n  - name: Andrea Gabrio\n    url: https://angabrio.github.io/agabriosite2/\n    orcid: 0000-0002-7650-4534\n    email: a.gabrio@maastrichtuniversity.nl\n    corresponding: true    \n    affiliation: Maastricht University\n    affiliation-url: https://www.maastrichtuniversity.nl/research/methodology-and-statistics\ndate: 2020-03-21\ncategories: [Quarto, R, Academia, Software, Statistics] # self-defined categories\n#image: featured.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\nabstract: > \n  [This tutorial will focus on the use of Bayesian estimation to fit simple linear regression models ...]{style=\"font-size: 85%\"}\nkeywords:\n  - Software\n  - Statistics\n  - Stan\n#license: \"GPL-2\"\n#copyright: \n#  holder: CRAN\n#  year: 2023\n#citation: \n#  title: missingHE\n#  author: Andrea Gabrio\n#  note: R package version 4.4.2\n#  url: https://cran.r-project.org/web/packages/missingHE\n#funding: \"The author received no specific funding for this work.\"\nbibliography: citations_stan14.bib\n#nocite: |\n#  @gabrio2017handling\n---\n\n\nThis tutorial will focus on the use of Bayesian estimation to fit simple linear regression models. `BUGS` (Bayesian inference Using *Gibbs Sampling*) is an algorithm and supporting language (resembling `R`) dedicated to performing the Gibbs sampling implementation of *Markov Chain Monte Carlo* (MCMC) method. Dialects of the `BUGS` language are implemented within three main projects:\n\n1. **OpenBUGS** - written in component pascal.\n \n2. **JAGS** - (Just Another Gibbs Sampler) - written in `C++`. \n\n3. **Stan** - a dedicated Bayesian modelling framework written in `C++` and implementing *Hamiltonian* MCMC samplers.\n\nWhilst the above programs can be used stand-alone, they do offer the rich data pre-processing and graphical capabilities of `R`, and thus, they are best accessed from within `R` itself. As such there are multiple packages devoted to interfacing with the various software implementations:\n\n* *R2OpenBUGS* - interfaces with `OpenBUGS`\n\n* *R2jags* - interfaces with `JAGS`\n\n* *rstan* - interfaces with `Stan`\n\nThis tutorial will demonstrate how to fit models in `Stan` (@gelman2015stan) using the package `rstan` (@rstanpackage) as interface, which also requires to load some other packages.\n\n# Overview\n\nItem response theory (IRT) is a paradigm for investigating the relationship between an individual’s response to a single test item and their performance on an overall measure of the ability or trait that item was intended to measure. Many models exist in the IRT field for evaulating how well an item captures an underlying latent trait, but some of the most popular IRT models are *logistic IRT models* for dichotmous responses. In particular, the main types of models are:\n\n  1 **1 parameter logistic model** \n  \n  2 **2 parameter logistic model**\n  \n  3 **3 parameter logistic model**\n\nThroughout this tutorial, I assume that the reader has some basic understanding of IRT model and working knowledge of a software implementation of the `Stan` language. However, if this is not the case, excellent sources for learning IRT are @baker2004item, who provide a mathematically detailed introduction to IRT, and @hambleton1991fundamentals, who give an intuitive introduction to the topic. For an in-depth description of how to implement different types of IRT models in `Stan`, I also refer to this very nice review of @luo2018using and this other online [tutorial](https://quantdev.ssri.psu.edu/sites/qdev/files/IRT_tutorial_FA17.html#3_2-parameter_logistic_(2pl)_irt_model).\n\nAt the core of all the IRT models presented in this tutorial is the *Item Response Function* (IRF). The IRF estimates the probability of getting item $j$ \"correct\" as a function of item characteristics and the $i$-th individual's latent trait/ability level ($\\theta_i$). These item response functions are defined by a logistic curve (i.e. an $S$-shape from $0-1$).\n\n# 1 parameter logistic model (1PLM)\n\nThe 1PLM is used for data collected on $n$ individuals who have each given responses on $p$ different items. The items have binary outcomes, i.e. the items are scored as $1$ if correct and $0$ if not. The $i$-th individual in the sample is assumed to have a latent ability $\\theta_i$, and the $i$-th individual's response on the $j$-th item is a random variable $Y_{ij}$ with a Bernoulli distribution. The probability that the $i$-th individual correctly answers the $j$-th item (i.e. the probability that $Y_{ij} = 1$) is assumed to have the following IRF form:\n\n$$\np_{ij} = P(Y_{ij}=1 \\mid \\theta_i,\\delta_j)=\\frac{1}{1+\\text{exp}(\\theta_i-\\delta_j)},\n$$\n\nwhere $\\delta_j$ is the *difficulty parameter* for item $j$ of the test, and is assumed to be normally distributed according to some mean $\\mu_{\\delta}$ and standard deviation $\\sigma_{\\delta}$ which must be specified by the analyst. Each *latent ability parameter* $\\theta_i$ is also assumed to be distributed according to a standard normal distribution.\n\n## Load the data\n\nI read in the data from the file `wideformat.csv`, which contains (simulated) data from $n=1000$ individuals taking a $5$-item test. Items are coded $1$ for correct and $0$ for incorrect responses. When we get descriptives of the data, we see that the items differ in terms of the proportion of people who answered correctly, so we expect that we have some differences in item difficulty here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_dicho<-read.csv(\"wideformat.csv\", sep = \",\")\nhead(data_dicho)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA        ID gender age Item.1 Item.2 Item.3 Item.4 Item.5\nNA 1 person1   Male  40      0      0      0      0      0\nNA 2 person2 Female  27      0      0      0      0      0\nNA 3 person3   Male  13      0      0      0      0      0\nNA 4 person4 Female  17      0      0      0      0      1\nNA 5 person5 Female  30      0      0      0      0      1\nNA 6 person6 Female  46      0      0      0      0      1\n```\n\n\n:::\n\n```{.r .cell-code}\n#check proportion of correct responses by item\napply(data_dicho[,4:8], 2, sum)/nrow(data_dicho)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Item.1 Item.2 Item.3 Item.4 Item.5 \nNA  0.924  0.709  0.553  0.763  0.870\n```\n\n\n:::\n\n```{.r .cell-code}\n#summarise the data\nlibrary(psych)\ndescribe(data_dicho)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA         vars    n   mean     sd median trimmed    mad min  max range  skew\nNA ID*        1 1000 500.50 288.82  500.5  500.50 370.65   1 1000   999  0.00\nNA gender*    2 1000   1.50   0.50    2.0    1.51   0.00   1    2     1 -0.02\nNA age        3 1000  25.37  14.43   25.0   25.36  17.79   1   50    49  0.01\nNA Item.1     4 1000   0.92   0.27    1.0    1.00   0.00   0    1     1 -3.20\nNA Item.2     5 1000   0.71   0.45    1.0    0.76   0.00   0    1     1 -0.92\nNA Item.3     6 1000   0.55   0.50    1.0    0.57   0.00   0    1     1 -0.21\nNA Item.4     7 1000   0.76   0.43    1.0    0.83   0.00   0    1     1 -1.24\nNA Item.5     8 1000   0.87   0.34    1.0    0.96   0.00   0    1     1 -2.20\nNA         kurtosis   se\nNA ID*        -1.20 9.13\nNA gender*    -2.00 0.02\nNA age        -1.21 0.46\nNA Item.1      8.22 0.01\nNA Item.2     -1.16 0.01\nNA Item.3     -1.96 0.02\nNA Item.4     -0.48 0.01\nNA Item.5      2.83 0.01\n```\n\n\n:::\n:::\n\n\n## Fit the model\n\nWe fit the 1PLM to the data. First, I rename and preprocess the data to be passed to `Stan`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nY<-data_dicho[,4:8]\nn<-nrow(Y)\np<-ncol(Y)\ndata_list<-list(Y=Y,n=n,p=p)\n```\n:::\n\n\nThen I specify the model using the following `Stan` code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel1<-\"\ndata {\nint<lower=0> n;\nint<lower=0> p;\nint<lower=0,upper=1> Y[n,p];\n}\nparameters {\nvector[n] theta;\nvector[p] delta;\nreal mu_delta;\nreal<lower=0> sigma_delta;\n}\ntransformed parameters{\nvector<lower=0,upper=1>[p] prob[n];\n for(i in 1:n){\n  for (j in 1:p){\n   prob[i,j] = inv_logit(theta[i] - delta[j]);\n  }\n }\n}\nmodel {\ntheta ~ normal(0,1);\ndelta ~ normal(mu_delta,sigma_delta);\nmu_delta ~ normal(0,5);\nsigma_delta ~ cauchy(0,5);\n for(i in 1:n){\n  for (j in 1:p){\n   Y[i,j] ~ bernoulli(prob[i,j]);\n  }\n }\n}\ngenerated quantities {\nvector[p] loglik_y[n];\nvector[p] Y_rep[n];\n for (i in 1: n){\n  for (j in 1: p){\n    loglik_y[i,j] = bernoulli_lpmf(Y[i,j] | prob[i,j]);\n    Y_rep[i,j] = bernoulli_rng(prob[i,j]); \n  }\n }\n}\n\"\n## write the model to a text file\nwriteLines(model1, con = \"model1PLM.stan\")\n```\n:::\n\n\nNext, I define the nodes (parameters and derivatives) to monitor and the chain parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- c(\"delta\", \"theta\", \"prob\",\"loglik_y\",\"Y_rep\")\nnChains = 2\nburnInSteps = 500\nthinSteps = 1\nnumSavedSteps = 2500  #across all chains\nnIter = ceiling(burnInSteps + (numSavedSteps * thinSteps)/nChains)\nnIter\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] 1750\n```\n\n\n:::\n:::\n\n\nStart the `Stan` model (check the model, load data into the model, specify the number of chains and compile the model). Run the `Stan` code via the `rstan` interface and the `stan` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rstan)\nset.seed(3456)\nmodel1_stan<- stan(data = data_list, file = \"model1PLM.stan\", \n                   chains = nChains, pars = params, iter = nIter, \n                   warmup = burnInSteps, thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA \nNA SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).\nNA Chain 1: \nNA Chain 1: Gradient evaluation took 0.000686 seconds\nNA Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 6.86 seconds.\nNA Chain 1: Adjust your expectations accordingly!\nNA Chain 1: \nNA Chain 1: \nNA Chain 1: Iteration:    1 / 1750 [  0%]  (Warmup)\nNA Chain 1: Iteration:  175 / 1750 [ 10%]  (Warmup)\nNA Chain 1: Iteration:  350 / 1750 [ 20%]  (Warmup)\nNA Chain 1: Iteration:  501 / 1750 [ 28%]  (Sampling)\nNA Chain 1: Iteration:  675 / 1750 [ 38%]  (Sampling)\nNA Chain 1: Iteration:  850 / 1750 [ 48%]  (Sampling)\nNA Chain 1: Iteration: 1025 / 1750 [ 58%]  (Sampling)\nNA Chain 1: Iteration: 1200 / 1750 [ 68%]  (Sampling)\nNA Chain 1: Iteration: 1375 / 1750 [ 78%]  (Sampling)\nNA Chain 1: Iteration: 1550 / 1750 [ 88%]  (Sampling)\nNA Chain 1: Iteration: 1725 / 1750 [ 98%]  (Sampling)\nNA Chain 1: Iteration: 1750 / 1750 [100%]  (Sampling)\nNA Chain 1: \nNA Chain 1:  Elapsed Time: 8.047 seconds (Warm-up)\nNA Chain 1:                11.298 seconds (Sampling)\nNA Chain 1:                19.345 seconds (Total)\nNA Chain 1: \nNA \nNA SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).\nNA Chain 2: \nNA Chain 2: Gradient evaluation took 0.000512 seconds\nNA Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 5.12 seconds.\nNA Chain 2: Adjust your expectations accordingly!\nNA Chain 2: \nNA Chain 2: \nNA Chain 2: Iteration:    1 / 1750 [  0%]  (Warmup)\nNA Chain 2: Iteration:  175 / 1750 [ 10%]  (Warmup)\nNA Chain 2: Iteration:  350 / 1750 [ 20%]  (Warmup)\nNA Chain 2: Iteration:  501 / 1750 [ 28%]  (Sampling)\nNA Chain 2: Iteration:  675 / 1750 [ 38%]  (Sampling)\nNA Chain 2: Iteration:  850 / 1750 [ 48%]  (Sampling)\nNA Chain 2: Iteration: 1025 / 1750 [ 58%]  (Sampling)\nNA Chain 2: Iteration: 1200 / 1750 [ 68%]  (Sampling)\nNA Chain 2: Iteration: 1375 / 1750 [ 78%]  (Sampling)\nNA Chain 2: Iteration: 1550 / 1750 [ 88%]  (Sampling)\nNA Chain 2: Iteration: 1725 / 1750 [ 98%]  (Sampling)\nNA Chain 2: Iteration: 1750 / 1750 [100%]  (Sampling)\nNA Chain 2: \nNA Chain 2:  Elapsed Time: 7.676 seconds (Warm-up)\nNA Chain 2:                11.291 seconds (Sampling)\nNA Chain 2:                18.967 seconds (Total)\nNA Chain 2:\n```\n\n\n:::\n:::\n\n\n##  Plot the item characteristic curves\n\n*Item characteristic curves* (ICC) are the logistic curves which result from the fitted models (e.g. estimated item difficulty, plugged into the item response function). Latent trait/ability is plotted on the $x$-axis (higher values represent hight ability). Probability of a “correct” answer ($Y_{ij}=1$) to an item is plotted on the $y$-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract parameters\nmodel1_stan_par<-extract(model1_stan)\n\n#see average value of item difficulty\ndiff<-model1_stan_par$delta\napply(diff,2,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] -2.8607139 -1.0645087 -0.2625512 -1.3897885 -2.2186421\n```\n\n\n:::\n\n```{.r .cell-code}\n#plot icc for each individual with respect to each of the 5 items\ntheta<-apply(model1_stan_par$theta, 2, mean)\nprob<-apply(model1_stan_par$prob,c(2,3),mean)\nplot(theta,prob[,1], type = \"n\", ylab = \"probability of correct response\", xlab=\"ability\",\n     xlim = c(-2.5,1), ylim = c(0,1))\nlines(theta,prob[,1],col=\"red\")\nlines(theta,prob[,2],col=\"blue\")\nlines(theta,prob[,3],col=\"orange\")\nlines(theta,prob[,4],col=\"green\")\nlines(theta,prob[,5],col=\"black\")\nlegend(\"bottomright\",legend = c(\"1\",\"2\",\"3\",\"4\",\"5\"), lty = c(1), col=c(\"red\",\"blue\",\"orange\",\"green\",\"black\"), bty = \"n\", cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nWe see that item $3$ is the most difficult item (it’s curve is farthest to the right), and item $1$ is the easiest (it’s curve is farthest to the left). The same conclusions can be drawn by checking the difficulty estimates above.\n\n## Plot the item information curves\n\n*Item information curves* (IIC) show how much “information” about the latent trait ability an item gives. Mathematically, these are the $1$st derivatives of the ICCs or, equivalently, to the product of the probability of correct and incorrect response. Item information curves peak at the difficulty value (point where the item has the highest discrimination), with less information at ability levels farther from the difficulty estimate. Practially speaking, we can see how a very difficult item will provide very little information about persons with low ability (because the item is already too hard), and very easy items will provide little information about persons with high ability levels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot iic for each individual with respect to each of the 5 items\nneg_prob<-1-prob\ninformation<-prob*neg_prob\nplot(theta,information[,1], type = \"n\", ylab = \"information\", xlab=\"ability\",\n     xlim = c(-2.5,1), ylim = c(0,0.3))\nlines(theta,information[,1],col=\"red\")\nlines(theta,information[,2],col=\"blue\")\nlines(theta,information[,3],col=\"orange\")\nlines(theta,information[,4],col=\"green\")\nlines(theta,information[,5],col=\"black\")\nlegend(\"bottomleft\",legend = c(\"1\",\"2\",\"3\",\"4\",\"5\"), lty = c(1), col=c(\"red\",\"blue\",\"orange\",\"green\",\"black\"), bty = \"n\", cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nSimilar to the ICCs, we see that item $3$ provides the most information about high ability levels (the peak of its IIC is farthest to the right) and item $1$ and $5$ provides the most information about lower ability levels (the peak of its IIC is farthest to the left). We have seen that all ICCs and IICs for the items have the same shape in the 1PL model (i.e. all items are equally good at providing information about the latent trait). In the 2PL and 3PL models, we will see that this does not have to be the case.\n\nNext, we plot the information curve for the whole test. This is simply the sum of the individual IICs above. Ideally, we want a test which provides fairly good covereage of a wide range of latent ability levels. Otherwise, the test is only good at identifying a limited range of ability levels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot iic for each individual with respect to whole test\ninformation_test<-apply(information,1,sum)\nplot(theta,information_test, type = \"n\", ylab = \"information (test)\", xlab=\"ability\",\n     xlim = c(-2.5,1), ylim = c(0,1.5))\nlines(theta,information_test,col=\"black\",lty=2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(information_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \nNA  0.5527  0.5698  0.7664  0.7753  0.9309  1.0789\n```\n\n\n:::\n:::\n\n\nWe see that this test provides the most information about low ability levels (the peak is around ability level $-1.5$), and less information about very high ability levels.\n\n## Assess fit\n\nWe perform posterior predictive checks to test whether individual items fit the 1PLM by comparing quantities computed from the predictions of the model with those from the observed data. If these match reasonably well, then there is indication that the model has a good fit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bayesplot)\nlibrary(ggplot2)\nY.rep<-model1_stan_par$Y_rep\n\n#Bar plot of y with yrep medians and uncertainty intervals superimposed on the bars\nppc_bars(Y[,1],Y.rep[1:8,,1]) + ggtitle(\"Item 1\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,2],Y.rep[1:8,,2]) + ggtitle(\"Item 2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,3],Y.rep[1:8,,3]) + ggtitle(\"Item 3\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-3.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,4],Y.rep[1:8,,4]) + ggtitle(\"Item 4\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-4.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,5],Y.rep[1:8,,5]) + ggtitle(\"Item 5\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-5.png){width=672}\n:::\n:::\n\n\n## Plot ability scores\n\nWe can conclude by summarising and plotting the latent ability scores of the participants\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#summary stats for theta across both iterations and individuals\nsummary(theta)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA       Min.    1st Qu.     Median       Mean    3rd Qu.       Max. \nNA -2.0462862 -0.4876188  0.0766153 -0.0001134  0.6947979  0.7444596\n```\n\n\n:::\n\n```{.r .cell-code}\n#histogram and kernel density plot of theta averaged across iterations\ndens.theta<-density(theta, bw=0.3)\nhist(theta, breaks = 5, prob = T)\nlines(dens.theta, lwd=2, col=\"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nWe see that the mean of ability scores is around $0$, and the standard deviation about $1$ (these are estimated ability scores are standardised).\n\n# 2 parameter logistic model (2PLM)\n\nIn the 2PLM, the probability that the $i$-th individual correctly answers the $j$-th item (i.e. the probability that $Y_{ij} = 1$) is assumed to have the following IRF form:\n\n$$\np_{ij} = P(Y_{ij}=1 \\mid \\theta_i,\\delta_j,\\alpha_j)=\\frac{1}{1+\\text{exp}(\\alpha_j(\\theta_i-\\delta_j))},\n$$\n\nwhere $\\alpha_j$ is the *discrimination parameter* for item $j$ of the test, and is assumed to be positive and lognormally distributed according to some mean $\\mu_{\\alpha}$ and standard deviation $\\sigma_{\\alpha}$ which must be specified by the analyst. The item discriminability $\\alpha_j$ indicates how well an item is able to discriminate between persons with different ability levels. Item discriminability is reflected in the steepness of the slope of the ICC.\n\n## Fit the model\n\nWe fit the 2PLM to the data using the following `Stan` code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel2<-\"\ndata {\nint<lower=0> n;\nint<lower=0> p;\nint<lower=0,upper=1> Y[n,p];\n}\nparameters {\nvector[n] theta;\nvector<lower=0> [p] alpha;\nvector[p] delta;\nreal mu_delta;\nreal<lower=0> sigma_alpha;\nreal<lower=0> sigma_delta;\n}\ntransformed parameters{\nvector<lower=0,upper=1>[p] prob[n];\n for(i in 1:n){\n  for (j in 1:p){\n   prob[i,j] = inv_logit(alpha[j]*(theta[i] - delta[j]));\n  }\n }\n}\nmodel {\ntheta ~ normal(0,1);\ndelta ~ normal(mu_delta,sigma_delta);\nmu_delta ~ normal(0,5);\nsigma_delta ~ cauchy(0,5);\nalpha ~ lognormal(0,sigma_alpha);\nsigma_alpha ~ cauchy(0,5);\n for(i in 1:n){\n  for (j in 1:p){\n   Y[i,j] ~ bernoulli(prob[i,j]);\n  }\n }\n}\ngenerated quantities {\nvector[p] loglik_y[n];\nvector[p] Y_rep[n];\n for (i in 1: n){\n  for (j in 1: p){\n    loglik_y[i,j] = bernoulli_lpmf(Y[i,j] | prob[i,j]);\n    Y_rep[i,j] = bernoulli_rng(prob[i,j]); \n  }\n }\n}\n\"\n## write the model to a text file\nwriteLines(model2, con = \"model2PLM.stan\")\n```\n:::\n\n\nNext, I define the nodes (parameters and derivatives) to monitor and the chain parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- c(\"delta\", \"alpha\",\"theta\", \"prob\",\"loglik_y\",\"Y_rep\")\nnChains = 2\nburnInSteps = 500\nthinSteps = 1\nnumSavedSteps = 2500  #across all chains\nnIter = ceiling(burnInSteps + (numSavedSteps * thinSteps)/nChains)\nnIter\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] 1750\n```\n\n\n:::\n:::\n\n\nStart the `Stan` model (check the model, load data into the model, specify the number of chains and compile the model). Run the `Stan` code via the `rstan` interface and the `stan` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(3456)\nmodel2_stan<- stan(data = data_list, file = \"model2PLM.stan\", \n                   chains = nChains, pars = params, iter = nIter, \n                   warmup = burnInSteps, thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA \nNA SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).\nNA Chain 1: \nNA Chain 1: Gradient evaluation took 0.000745 seconds\nNA Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 7.45 seconds.\nNA Chain 1: Adjust your expectations accordingly!\nNA Chain 1: \nNA Chain 1: \nNA Chain 1: Iteration:    1 / 1750 [  0%]  (Warmup)\nNA Chain 1: Iteration:  175 / 1750 [ 10%]  (Warmup)\nNA Chain 1: Iteration:  350 / 1750 [ 20%]  (Warmup)\nNA Chain 1: Iteration:  501 / 1750 [ 28%]  (Sampling)\nNA Chain 1: Iteration:  675 / 1750 [ 38%]  (Sampling)\nNA Chain 1: Iteration:  850 / 1750 [ 48%]  (Sampling)\nNA Chain 1: Iteration: 1025 / 1750 [ 58%]  (Sampling)\nNA Chain 1: Iteration: 1200 / 1750 [ 68%]  (Sampling)\nNA Chain 1: Iteration: 1375 / 1750 [ 78%]  (Sampling)\nNA Chain 1: Iteration: 1550 / 1750 [ 88%]  (Sampling)\nNA Chain 1: Iteration: 1725 / 1750 [ 98%]  (Sampling)\nNA Chain 1: Iteration: 1750 / 1750 [100%]  (Sampling)\nNA Chain 1: \nNA Chain 1:  Elapsed Time: 17.619 seconds (Warm-up)\nNA Chain 1:                49.041 seconds (Sampling)\nNA Chain 1:                66.66 seconds (Total)\nNA Chain 1: \nNA \nNA SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).\nNA Chain 2: \nNA Chain 2: Gradient evaluation took 0.001071 seconds\nNA Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 10.71 seconds.\nNA Chain 2: Adjust your expectations accordingly!\nNA Chain 2: \nNA Chain 2: \nNA Chain 2: Iteration:    1 / 1750 [  0%]  (Warmup)\nNA Chain 2: Iteration:  175 / 1750 [ 10%]  (Warmup)\nNA Chain 2: Iteration:  350 / 1750 [ 20%]  (Warmup)\nNA Chain 2: Iteration:  501 / 1750 [ 28%]  (Sampling)\nNA Chain 2: Iteration:  675 / 1750 [ 38%]  (Sampling)\nNA Chain 2: Iteration:  850 / 1750 [ 48%]  (Sampling)\nNA Chain 2: Iteration: 1025 / 1750 [ 58%]  (Sampling)\nNA Chain 2: Iteration: 1200 / 1750 [ 68%]  (Sampling)\nNA Chain 2: Iteration: 1375 / 1750 [ 78%]  (Sampling)\nNA Chain 2: Iteration: 1550 / 1750 [ 88%]  (Sampling)\nNA Chain 2: Iteration: 1725 / 1750 [ 98%]  (Sampling)\nNA Chain 2: Iteration: 1750 / 1750 [100%]  (Sampling)\nNA Chain 2: \nNA Chain 2:  Elapsed Time: 16.85 seconds (Warm-up)\nNA Chain 2:                25.604 seconds (Sampling)\nNA Chain 2:                42.454 seconds (Total)\nNA Chain 2:\n```\n\n\n:::\n:::\n\n\n##  Plot the item characteristic curves\n\n*Item characteristic curves* (ICC) are the logistic curves which result from the fitted models (e.g. estimated item difficulty, plugged into the item response function). Latent trait/ability is plotted on the $x$-axis (higher values represent hight ability). Probability of a “correct” answer ($Y_{ij}=1$) to an item is plotted on the $y$-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract parameters\nmodel2_stan_par<-extract(model2_stan)\n\ndiscr<-model2_stan_par$alpha\ndiff<-model2_stan_par$delta\n#see average value of item difficulty\napply(diff,2,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] -3.1999792 -1.3773558 -0.3093908 -1.8061242 -2.7793706\n```\n\n\n:::\n\n```{.r .cell-code}\n#see average value of item discriminability\napply(discr,2,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] 0.9180807 0.7605854 0.8462632 0.7522866 0.7916501\n```\n\n\n:::\n\n```{.r .cell-code}\n#plot icc for each individual with respect to each of the 5 items\ntheta<-apply(model2_stan_par$theta, 2, mean)\nprob<-apply(model2_stan_par$prob,c(2,3),mean)\nplot(theta,prob[,1], type = \"n\", ylab = \"probability of correct response\", xlab=\"ability\",xlim = c(-2.5,1), ylim = c(0,1))\nlines(theta,prob[,1],col=\"red\")\nlines(theta,prob[,2],col=\"blue\")\nlines(theta,prob[,3],col=\"orange\")\nlines(theta,prob[,4],col=\"green\")\nlines(theta,prob[,5],col=\"black\")\nlegend(\"bottomright\",legend = c(\"1\",\"2\",\"3\",\"4\",\"5\"), lty = c(1), col=c(\"red\",\"blue\",\"orange\",\"green\",\"black\"), bty = \"n\", cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nUnlike the ICCs for the 1PLM, the ICCs for the 2PLM do not all have the same shape. Item curves which are more “spread out” indicate lower discriminability (i.e. that individuals of a range of ability levels have some probability of getting the item correct). Compare this to an item with high discriminability (steep slope): for this item, we have a better estimate of the individual’s latent ability based on whether they got the question right or wrong. Because of the differing slopes, the rank-order of item difficulty changes across different latent ability levels. We can see that item $3$ is still the most difficult item (i.e. lowest probability of getting correct for most latent trait values, up until about $\\theta=0.2$). Items $1$ and $5$ are the easiest.\n\n## Plot the item information curves\n\n*Item information curves* (IIC) show how much “information” about the latent trait ability an item gives. Mathematically, these are the $1$st derivatives of the ICCs or, equivalently, to the product of the probability of correct and incorrect response. Item information curves peak at the difficulty value (point where the item has the highest discrimination), with less information at ability levels farther from the difficulty estimate. Practially speaking, we can see how a very difficult item will provide very little information about persons with low ability (because the item is already too hard), and very easy items will provide little information about persons with high ability levels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot iic for each individual with respect to each of the 5 items\nneg_prob<-1-prob\ninformation<-prob*neg_prob\ninformation2<-information*(apply(discr,2,mean))^2\nplot(theta,information2[,1], type = \"n\", ylab = \"information\", xlab=\"ability\",\n     xlim = c(-2.5,1), ylim = c(0,0.3))\nlines(theta,information2[,1],col=\"red\")\nlines(theta,information2[,2],col=\"blue\")\nlines(theta,information2[,3],col=\"orange\")\nlines(theta,information2[,4],col=\"green\")\nlines(theta,information2[,5],col=\"black\")\nlegend(\"bottomleft\",legend = c(\"1\",\"2\",\"3\",\"4\",\"5\"), lty = c(1), col=c(\"red\",\"blue\",\"orange\",\"green\",\"black\"), bty = \"n\", cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nThe item IICs demonstrate that some items provide more information about latent ability for different ability levels. The higher the item discriminability estimate, the more information an item provides about ability levels around the point where there is a $50\\%$ chance of getting the item right (i.e. the steepest point in the ICC slope). For example, item $3$ (orange) clearly provides the most information at high ability levels, around $\\theta=-0.5$, but almost no information about low ability levels ($< -1$) because the item is already too hard for those participants. In contrast, item $1$ (red), which has low discriminability, doesn’t give very much information overall, but covers a wide range of ability levels.\n\nNext, we plot the item information curve for the whole test. This is the sum of all the item IICs above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot iic for each individual with respect to whole test\ninformation_test<-apply(information2,1,sum)\nplot(theta,information_test, type = \"n\", ylab = \"information (test)\", xlab=\"ability\",\n     xlim = c(-2.5,1), ylim = c(0,1.5))\nlines(theta,information_test,col=\"black\",lty=2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(information_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \nNA  0.3521  0.4463  0.5206  0.5280  0.5837  0.9238\n```\n\n\n:::\n:::\n\n\nThe IIC for the whole test shows that the test provides the most information for slightly-lower-than average ability levels (about $\\theta=-1$), but does not provide much information about extremely high ability levels.\n\n## Assess fit\n\nNext, we check how well the 2PLM fits the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nY.rep<-model2_stan_par$Y_rep\n\n#Bar plot of y with yrep medians and uncertainty intervals superimposed on the bars\nppc_bars(Y[,1],Y.rep[1:8,,1]) + ggtitle(\"Item 1\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,2],Y.rep[1:8,,2]) + ggtitle(\"Item 2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,3],Y.rep[1:8,,3]) + ggtitle(\"Item 3\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-3.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,4],Y.rep[1:8,,4]) + ggtitle(\"Item 4\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-4.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,5],Y.rep[1:8,,5]) + ggtitle(\"Item 5\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-5.png){width=672}\n:::\n:::\n\n\nWe can also compare the fit of the 1PLM and 2PLM using relative measures of fit or *information criteria*. These are computed based on the deviance and a penalty for model complexity called the effective number of parameters $p$. Here we consider two Bayesian measures known as the *Widely Applicable* (WAIC) and *Leave One Out* (LOOIC) Information Criterion, which can be easily obtained through the functions `waic` and `loo` in the package `loo`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(loo)\n#extract log-likelihood\nloglik_m1<-model1_stan_par$loglik_y\nloglik_m2<-model2_stan_par$loglik_y\n\n#waic\nwaic_m1<-waic(loglik_m1)\nwaic_m2<-waic(loglik_m2)\n\n#looic\nlooic_m1<-loo(loglik_m1)\nlooic_m2<-loo(loglik_m2)\n\n#compare\ntable_waic<-rbind(waic_m1$estimates[2:3,1],waic_m2$estimates[2:3,1])\ntable_looic<-rbind(looic_m1$estimates[2:3,1],looic_m2$estimates[2:3,1])\nrownames(table_waic)<-rownames(table_looic)<-c(\"1PLM\",\"2PLM\")\nknitr::kable(cbind(table_waic,table_looic), \"pandoc\", align = \"c\")\n```\n\n::: {.cell-output-display}\n\n         p_waic       waic       p_loo       looic   \n-----  ----------  ----------  ----------  ----------\n1PLM    1.528685    6.524715    1.872122    7.211591 \n2PLM    1.425271    6.459973    1.707341    7.024112 \n\n\n:::\n:::\n\n\nBoth criteria suggest that the 2PLM has a slightly better fit to the data.\n\n## Plot ability scores\n\nPlot the density curve of the estimated ability scores\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#summary stats for theta across both iterations and individuals\nsummary(theta)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA       Min.    1st Qu.     Median       Mean    3rd Qu.       Max. \nNA -1.9620636 -0.4347622  0.0659988  0.0006122  0.6347629  0.6738680\n```\n\n\n:::\n\n```{.r .cell-code}\n#histogram and kernel density plot of theta averaged across iterations\ndens.theta<-density(theta, bw=0.3)\nhist(theta, breaks = 5, prob = T)\nlines(dens.theta, lwd=2, col=\"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nWe see that the mean of ability scores is around $0$, and the standard deviation about $1$ (these are estimated ability scores are standardised).\n\n# 3 parameter logistic model (3PLM)\n\nIn the 3PLM, the probability that the $i$-th individual correctly answers the $j$-th item (i.e. the probability that $Y_{ij} = 1$) is assumed to have the following IRF form:\n\n$$\np_{ij} = P(Y_{ij}=1 \\mid \\theta_i,\\delta_j,\\alpha_j,\\eta_j)=\\eta_j + (1-\\eta_j) \\frac{1}{1+\\text{exp}(\\alpha_j(\\theta_i-\\delta_j))},\n$$\n\nwhere $\\eta_j$ is the *guessing parameter*. Under this model, individuals with zero ability have a nonzero chance of endorsing any item, just by guessing randomly. The guessing parameter is reflected in the $y$-intercept (i.e. probability) of the ICC. The parameter is normally distributed according to some mean $\\mu_{\\eta}$ and standard deviation $\\sigma_{\\eta}$ which must be specified by the analyst.\n\n## Fit the model\n\nWe fit the 3PLM to the data using the following `Stan` code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel3<-\"\ndata {\nint<lower=0> n;\nint<lower=0> p;\nint<lower=0,upper=1> Y[n,p];\n}\nparameters {\nvector[n] theta;\nvector<lower=0> [p] alpha;\nvector[p] delta;\nvector<lower=0,upper=1>[p] eta; //item pseudo-guessing\nreal mu_delta;\nreal<lower=0> sigma_alpha;\nreal<lower=0> sigma_delta;\n}\ntransformed parameters{\nvector<lower=0,upper=1>[p] prob_star[n];\nvector<lower=0,upper=1>[p] prob[n];\n for(i in 1:n){\n  for (j in 1:p){\n   prob_star[i,j] = inv_logit(alpha[j]*(theta[i] - delta[j]));\n   prob[i, j] = eta[j] + (1-eta[j])*prob_star[i,j]; \n  }\n }\n}\nmodel {\ntheta ~ normal(0,1);\ndelta ~ normal(mu_delta,sigma_delta);\nmu_delta ~ normal(0,5);\nsigma_delta ~ cauchy(0,5);\nalpha ~ lognormal(0,sigma_alpha);\nsigma_alpha ~ cauchy(0,5);\neta ~ beta(5,23);\n for(i in 1:n){\n  for (j in 1:p){\n   Y[i,j] ~ bernoulli(prob[i,j]);\n  }\n }\n}\ngenerated quantities {\nvector[p] loglik_y[n];\nvector[p] Y_rep[n];\n for (i in 1: n){\n  for (j in 1: p){\n    loglik_y[i,j] = bernoulli_lpmf(Y[i,j] | prob[i,j]);\n    Y_rep[i,j] = bernoulli_rng(prob[i,j]); \n  }\n }\n}\n\"\n## write the model to a text file\nwriteLines(model3, con = \"model3PLM.stan\")\n```\n:::\n\n\nNext, I define the nodes (parameters and derivatives) to monitor and the chain parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- c(\"delta\", \"alpha\", \"eta\",\"theta\", \"prob\",\"loglik_y\",\"Y_rep\")\nnChains = 2\nburnInSteps = 500\nthinSteps = 1\nnumSavedSteps = 2500  #across all chains\nnIter = ceiling(burnInSteps + (numSavedSteps * thinSteps)/nChains)\nnIter\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] 1750\n```\n\n\n:::\n:::\n\n\nStart the `Stan` model (check the model, load data into the model, specify the number of chains and compile the model). Run the `Stan` code via the `rstan` interface and the `stan` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(3456)\nmodel3_stan<- stan(data = data_list, file = \"model3PLM.stan\", \n                   chains = nChains, pars = params, iter = nIter, \n                   warmup = burnInSteps, thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA \nNA SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).\nNA Chain 1: \nNA Chain 1: Gradient evaluation took 0.000959 seconds\nNA Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 9.59 seconds.\nNA Chain 1: Adjust your expectations accordingly!\nNA Chain 1: \nNA Chain 1: \nNA Chain 1: Iteration:    1 / 1750 [  0%]  (Warmup)\nNA Chain 1: Iteration:  175 / 1750 [ 10%]  (Warmup)\nNA Chain 1: Iteration:  350 / 1750 [ 20%]  (Warmup)\nNA Chain 1: Iteration:  501 / 1750 [ 28%]  (Sampling)\nNA Chain 1: Iteration:  675 / 1750 [ 38%]  (Sampling)\nNA Chain 1: Iteration:  850 / 1750 [ 48%]  (Sampling)\nNA Chain 1: Iteration: 1025 / 1750 [ 58%]  (Sampling)\nNA Chain 1: Iteration: 1200 / 1750 [ 68%]  (Sampling)\nNA Chain 1: Iteration: 1375 / 1750 [ 78%]  (Sampling)\nNA Chain 1: Iteration: 1550 / 1750 [ 88%]  (Sampling)\nNA Chain 1: Iteration: 1725 / 1750 [ 98%]  (Sampling)\nNA Chain 1: Iteration: 1750 / 1750 [100%]  (Sampling)\nNA Chain 1: \nNA Chain 1:  Elapsed Time: 15.626 seconds (Warm-up)\nNA Chain 1:                29.036 seconds (Sampling)\nNA Chain 1:                44.662 seconds (Total)\nNA Chain 1: \nNA \nNA SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).\nNA Chain 2: \nNA Chain 2: Gradient evaluation took 0.000674 seconds\nNA Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 6.74 seconds.\nNA Chain 2: Adjust your expectations accordingly!\nNA Chain 2: \nNA Chain 2: \nNA Chain 2: Iteration:    1 / 1750 [  0%]  (Warmup)\nNA Chain 2: Iteration:  175 / 1750 [ 10%]  (Warmup)\nNA Chain 2: Iteration:  350 / 1750 [ 20%]  (Warmup)\nNA Chain 2: Iteration:  501 / 1750 [ 28%]  (Sampling)\nNA Chain 2: Iteration:  675 / 1750 [ 38%]  (Sampling)\nNA Chain 2: Iteration:  850 / 1750 [ 48%]  (Sampling)\nNA Chain 2: Iteration: 1025 / 1750 [ 58%]  (Sampling)\nNA Chain 2: Iteration: 1200 / 1750 [ 68%]  (Sampling)\nNA Chain 2: Iteration: 1375 / 1750 [ 78%]  (Sampling)\nNA Chain 2: Iteration: 1550 / 1750 [ 88%]  (Sampling)\nNA Chain 2: Iteration: 1725 / 1750 [ 98%]  (Sampling)\nNA Chain 2: Iteration: 1750 / 1750 [100%]  (Sampling)\nNA Chain 2: \nNA Chain 2:  Elapsed Time: 17.019 seconds (Warm-up)\nNA Chain 2:                29.021 seconds (Sampling)\nNA Chain 2:                46.04 seconds (Total)\nNA Chain 2:\n```\n\n\n:::\n:::\n\n\n##  Plot the item characteristic curves\n\n*Item characteristic curves* (ICC) are the logistic curves which result from the fitted models (e.g. estimated item difficulty, plugged into the item response function). Latent trait/ability is plotted on the $x$-axis (higher values represent hight ability). Probability of a “correct” answer ($Y_{ij}=1$) to an item is plotted on the $y$-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract parameters\nmodel3_stan_par<-extract(model3_stan)\n\ndiscr<-model3_stan_par$alpha\ndiff<-model3_stan_par$delta\ngues<-model3_stan_par$eta\n#see average value of item difficulty\napply(diff,2,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] -2.8000531 -0.7982283  0.1709581 -1.2011374 -2.1901744\n```\n\n\n:::\n\n```{.r .cell-code}\n#see average value of item discriminability\napply(discr,2,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] 0.9504686 0.8863304 1.0198040 0.8720698 0.8853051\n```\n\n\n:::\n\n```{.r .cell-code}\n#see average value of item guessing\napply(gues,2,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA [1] 0.1894722 0.1841677 0.1635017 0.1926284 0.1920851\n```\n\n\n:::\n\n```{.r .cell-code}\n#plot icc for each individual with respect to each of the 5 items\ntheta<-apply(model3_stan_par$theta, 2, mean)\nprob<-apply(model3_stan_par$prob,c(2,3),mean)\nplot(theta,prob[,1], type = \"n\", ylab = \"probability of correct response\", xlab=\"ability\",\n     xlim = c(-2.5,1), ylim = c(0,1))\nlines(theta,prob[,1],col=\"red\")\nlines(theta,prob[,2],col=\"blue\")\nlines(theta,prob[,3],col=\"orange\")\nlines(theta,prob[,4],col=\"green\")\nlines(theta,prob[,5],col=\"black\")\nlegend(\"bottomright\",legend = c(\"1\",\"2\",\"3\",\"4\",\"5\"), lty = c(1), col=c(\"red\",\"blue\",\"orange\",\"green\",\"black\"), bty = \"n\", cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nThe slopes of the ICCs look very similar to those of the 2PLM. We can see that all items have $y$-intercepts greater than zero, so that even at very low ability levels, there is some chance of getting these items correct (via guessing).\n\n## Plot the item information curves\n\n*Item information curves* (IIC) show how much “information” about the latent trait ability an item gives. Mathematically, these are the $1$st derivatives of the ICCs or, equivalently, to the product of the probability of correct and incorrect response. Item information curves peak at the difficulty value (point where the item has the highest discrimination), with less information at ability levels farther from the difficulty estimate. Practially speaking, we can see how a very difficult item will provide very little information about persons with low ability (because the item is already too hard), and very easy items will provide little information about persons with high ability levels.\n\nHere I plot the IICs using points, rather than lines, to better display the patterns of the individuals, which vary substantially according to whether the item was correctly chosen due to chance or not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot iic for each individual with respect to each of the 5 items\nneg_prob<-1-prob\ninformation.p1<-neg_prob/prob\ninformation.p2<-(prob-apply(gues,2,mean))^2/(1-apply(gues,2,mean))^2\ninformation3<-(apply(discr,2,mean))^2*(information.p2)*(information.p1)\nplot(theta,information3[,1], type = \"n\", ylab = \"information\", xlab=\"ability\",\n     xlim = c(-2.5,1), ylim = c(0,0.7))\npoints(theta,information3[,1],col=\"red\")\npoints(theta,information3[,2],col=\"blue\")\npoints(theta,information3[,3],col=\"orange\")\npoints(theta,information3[,4],col=\"green\")\npoints(theta,information3[,5],col=\"black\")\nlegend(\"bottomleft\",legend = c(\"1\",\"2\",\"3\",\"4\",\"5\"), lty = c(1), col=c(\"red\",\"blue\",\"orange\",\"green\",\"black\"), bty = \"n\", cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nNext, we plot the item information curve for the whole test. This is the sum of all the item IICs above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot iic for each individual with respect to whole test\ninformation_test<-apply(information3,1,sum)\nplot(theta,information_test, type = \"n\", ylab = \"information (test)\", xlab=\"ability\",\n     xlim = c(-2.5,1), ylim = c(0,1.5))\npoints(theta,information_test,col=\"black\",lty=2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(information_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \nNA  0.4050  0.4876  0.5259  0.5430  0.5794  0.7800\n```\n\n\n:::\n:::\n\n\n## Assess fit\n\nNext, we check how well the 3PLM fits the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nY.rep<-model3_stan_par$Y_rep\n\n#Bar plot of y with yrep medians and uncertainty intervals superimposed on the bars\nppc_bars(Y[,1],Y.rep[1:8,,1]) + ggtitle(\"Item 1\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,2],Y.rep[1:8,,2]) + ggtitle(\"Item 2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-2.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,3],Y.rep[1:8,,3]) + ggtitle(\"Item 3\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-3.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,4],Y.rep[1:8,,4]) + ggtitle(\"Item 4\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-4.png){width=672}\n:::\n\n```{.r .cell-code}\nppc_bars(Y[,5],Y.rep[1:8,,5]) + ggtitle(\"Item 5\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-5.png){width=672}\n:::\n:::\n\n\nWe can also compare the fit of the 1PLM, 2PLM and 3PLM using relative measures of fit or *information criteria*. These are computed based on the deviance and a penalty for model complexity called the effective number of parameters $p$. Here we consider two Bayesian measures known as the *Widely Applicable* (WAIC) and *Leave One Out* (LOOIC) Information Criterion, which can be easily obtained through the functions `waic` and `loo` in the package `loo`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract log-likelihood\nloglik_m3<-model3_stan_par$loglik_y\n\n#waic\nwaic_m3<-waic(loglik_m3)\n\n#looic\nlooic_m3<-loo(loglik_m3)\n\n#compare\ntable_waic<-rbind(waic_m1$estimates[2:3,1],waic_m2$estimates[2:3,1],waic_m3$estimates[2:3,1])\ntable_looic<-rbind(looic_m1$estimates[2:3,1],looic_m2$estimates[2:3,1],looic_m3$estimates[2:3,1])\nrownames(table_waic)<-rownames(table_looic)<-c(\"1PLM\",\"2PLM\",\"3PLM\")\nknitr::kable(cbind(table_waic,table_looic), \"pandoc\", align = \"c\")\n```\n\n::: {.cell-output-display}\n\n         p_waic       waic       p_loo       looic   \n-----  ----------  ----------  ----------  ----------\n1PLM    1.528685    6.524715    1.872122    7.211591 \n2PLM    1.425271    6.459973    1.707341    7.024112 \n3PLM    1.404317    6.431826    1.696826    7.016845 \n\n\n:::\n:::\n\n\nBoth criteria suggest that both 1PLM and 2PLM have a better fit to the data than 3PLM.\n\n## Plot ability scores\n\nPlot the density curve of the estimated ability scores\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#summary stats for theta across both iterations and individuals\nsummary(theta)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA       Min.    1st Qu.     Median       Mean    3rd Qu.       Max. \nNA -1.8453432 -0.4371787  0.0632952  0.0001144  0.6473378  0.7082924\n```\n\n\n:::\n\n```{.r .cell-code}\n#histogram and kernel density plot of theta averaged across iterations\ndens.theta<-density(theta, bw=0.3)\nhist(theta, breaks = 5, prob = T)\nlines(dens.theta, lwd=2, col=\"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nWe see that the mean of ability scores is around $0$, and the standard deviation about $1$ (these are estimated ability scores are standardised).\n\n\n# Conclusions\n\nThe use of `Stan` software to estimate IRT models allows the user to alter existing\ncode to fit new variations of current models that cannot be fit in existing software packages. For example, longitudinal or multilevel data can easily be accommodated by small changes to existing `Stan` code. The `Stan` software takes care of the \"grunt work\" involved in estimating model parameters by constructing an MCMC algorithm to sample from the posterior distribution. Using `Stan` frees the user to experiment with different models that may be more appropriate for specialised data than the models that can currently be fit in other software packages. Of course, more complicated models involve more parameters than simpler models, and the analyst must specify prior distributions for these new parameters. This is a small price to pay, however, for the flexibility that the Bayesian framework and `Stan` software provide.\n\n# References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}