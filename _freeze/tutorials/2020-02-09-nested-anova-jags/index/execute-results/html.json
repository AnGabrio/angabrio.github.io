{
  "hash": "be31e998f7d1b8e82e27bcad135e7a0d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Nested Anova (JAGS)\"\ndescription: \"\"\nauthor:\n  - name: Andrea Gabrio\n    url: https://angabrio.github.io/agabriosite2/\n    orcid: 0000-0002-7650-4534\n    email: a.gabrio@maastrichtuniversity.nl\n    corresponding: true    \n    affiliation: Maastricht University\n    affiliation-url: https://www.maastrichtuniversity.nl/research/methodology-and-statistics\ndate: 2020-02-09\ncategories: [Quarto, R, Academia, Software, Statistics] # self-defined categories\n#image: featured.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\nabstract: > \n  [This tutorial will focus on the use of Bayesian estimation to fit simple linear regression models ...]{style=\"font-size: 85%\"}\nkeywords:\n  - Software\n  - Statistics\n  - Stan\n#license: \"GPL-2\"\n#copyright: \n#  holder: CRAN\n#  year: 2023\n#citation: \n#  title: missingHE\n#  author: Andrea Gabrio\n#  note: R package version 4.4.2\n#  url: https://cran.r-project.org/web/packages/missingHE\n#funding: \"The author received no specific funding for this work.\"\nbibliography: citations_jags10.bib\n#nocite: |\n#  @gabrio2017handling\n---\n\n\nThis tutorial will focus on the use of Bayesian estimation to fit simple linear regression models. `BUGS` (Bayesian inference Using *Gibbs Sampling*) is an algorithm and supporting language (resembling `R`) dedicated to performing the Gibbs sampling implementation of *Markov Chain Monte Carlo* (MCMC) method. Dialects of the `BUGS` language are implemented within three main projects:\n\n1. **OpenBUGS** - written in component pascal.\n \n2. **JAGS** - (Just Another Gibbs Sampler) - written in `C++`. \n\n3. **STAN** - a dedicated Bayesian modelling framework written in `C++` and implementing *Hamiltonian* MCMC samplers.\n\nWhilst the above programs can be used stand-alone, they do offer the rich data pre-processing and graphical capabilities of `R`, and thus, they are best accessed from within `R` itself. As such there are multiple packages devoted to interfacing with the various software implementations:\n\n* *R2OpenBUGS* - interfaces with `OpenBUGS`\n\n* *R2jags* - interfaces with `JAGS`\n\n* *rstan* - interfaces with `STAN`\n\nThis tutorial will demonstrate how to fit models in `JAGS` (@plummer2004jags) using the package `R2jags` (@su2015package) as interface, which also requires to load some other packages.\n\n# Overview\n\n## Introduction\n\nWhen single sampling units are selected amongst highly heterogeneous conditions, it is unlikely that these single units will adequately represent the populations and repeated sampling is likely to yield very different outcomes. For example, if we were investigating the impacts of fuel reduction burning across a highly heterogeneous landscape, our ability to replicate adequately might be limited by the number of burn sites available.\n\nAlternatively, sub-replicates within each of the sampling units (e.g. sites) can be collected (and averaged) so as to provided better representatives for each of the units and ultimately reduce the unexplained variability of the test of treatments. In essence, the sub-replicates are the replicates of an additional nested factor whose levels are nested within the main treatment factor. A nested factor refers to a factor whose levels are unique within each level of the factor it is nested within and each level is only represented once. For example, the fuel reduction burn study design could consist of three burnt sites and three un-burnt (control) sites each containing four quadrats (replicates of site and sub-replicates of the burn treatment). Each site represents a unique level of a random factor (any given site cannot be both burnt and un-burnt) that is nested within the fire treatment (burned or not).\n\nA nested design can be thought of as a hierarchical arrangement of factors (hence the alternative name hierarchical designs) whereby a treatment is progressively sub-replicated. As an additional example, imagine an experiment designed to comparing the leaf toughness of a number of tree species. Working down the hierarchy, five individual trees were randomly selected within (nested within) each species, three branches were randomly selected within each tree, two leaves were randomly selected within each branch and the force required to shear the leaf material in half (transversely) was measured in four random locations along the leaf. Clearly any given leaf can only be from a single branch, tree and species. Each level of sub-replication is introduced to further reduce the amount of unexplained variation and thereby increasing the power of the test for the main treatment effect. Additionally, it is possible to investigate which scale has the greatest (or least, etc) degree of variability - the level of the species, individual tree, branch, leaf, leaf region etc. \n\n* Nested factors are typically random factors, of which the levels are randomly selected to represent all possible levels (e.g. sites). When the main treatment effect (often referred to as Factor A) is a fixed factor, such designs are referred to as a *mixed model nested ANOVA*, whereas when Factor A is random, the design is referred to as a *Model II nested ANOVA*. \n\n* Fixed nested factors are also possible. For example, specific dates (corresponding to particular times during a season) could be nested within season. When all factors are fixed, the design is referred to as a *Model I mixed model*. \n\n* Fully nested designs (the topic of this chapter) differ from other multi-factor designs in that all factors within (below) the main treatment factor are nested and thus interactions are un-replicated and cannot be tested. Indeed, interaction effects (interaction between Factor A and site) are assumed to be zero.\n\n## Linear models (frequentist)\n\nThe linear models for two and three factor nested design are:\n\n$$\ny_{ijk} = \\mu + \\alpha_i + \\beta_{j(i)} + \\epsilon_{ijk},\n$$\n\n$$\ny_{ijkl} = \\mu + \\alpha_i + \\beta_{j(i)} + gamma_{k(j(i))}  + \\epsilon_{ijkl},\n$$\n\nwhere $\\mu$ is the overall mean, $\\alpha$ is the effect of Factor A, $\\beta$ is the effect of Factor B, $\\gamma$ is the effect of Factor C and $\\epsilon$ is the random unexplained or residual component.\n\n## Linear models (Bayesian)\n\nSo called \"random effects\" are modelled differently from \"fixed effects\" in that rather than estimate their individual effects, we instead estimate the variability due to these \"random effects\". Since technically all variables in a Bayesian framework are random, some prefer to use the terms 'fixed effects' and 'varying effects'. As random factors typically represent \"random\" selections of levels (such as a set of randomly selected sites), incorporated in order to account for the dependency structure (observations within sites are more likely to be correlated to one another - not strickly independent) to the data, we are not overly interested in the individual differences between levels of the 'varying' (random) factor. Instead (in addition to imposing a separate correlation structure within each nest), we want to know how much variability is attributed to this level of the design. The linear models for two and three factor nested design are:\n\n$$\ny_{ijk} = \\mu + \\alpha_i + \\beta_{j(i)} + \\epsilon_{ijk}, \\;\\;\\; \\epsilon_{ijk} \\sim N(0, \\sigma^2), \\;\\;\\; \\beta_{j(i)} \\sim N(0, \\sigma^2_{B}) \n$$\n\n$$\ny_{ijkl} = \\mu + \\alpha_i + \\beta_{j(i)} + \\gamma_{k(j(i))} + \\epsilon_{ijkl}, \\;\\;\\; \\epsilon_{ijkl} \\sim N(0, \\sigma^2), \\;\\;\\; \\beta_{j(i)} \\sim N(0, \\sigma^2_{B}) \\;\\;\\; \\gamma_{k(j(i))} \\sim N(0, \\sigma^2_C) \n$$\n\nwhere $\\mu$ is the overall mean, $\\alpha$ is the effect of Factor A, $\\beta$ is the variability of Factor B (nested within Factor A), $\\gamma$ is the variability of Factor C (nested within Factor B) and $\\epsilon$ is the random unexplained or residual component that is assumed to be normally distributed with a mean of zero and a constant amount of standard deviation ($\\sigma^2$). The subscripts are iterators. For example, the $i$ represents the number of effects to be estimated for Factor A. Thus the first formula can be read as the $k$-th observation of $y$ is drawn from a normal distribution (with a specific level of variability) and mean proposed to be determined by a base mean ($\\mu$ - mean of the first treatment across all nests) plus the effect of the $i$-th treatment effect plus the variabilitythe model proposes that, given a base mean ($\\mu$) and knowing the effect of the $i$-th treatment (factor A) and which of the $j$-th nests within the treatment the $k$-th observation from Block $j$ (factor B) within treatment effect.\n\n## Null hypotheses\n\nSeparate null hypotheses are associated with each of the factors, however, nested factors are typically only added to absorb some of the unexplained variability and thus, specific hypotheses tests associated with nested factors are of lesser biological importance. Hence, rather than estimate the effects of random effects, we instead estimate how much variability they contribute.\n\n**Factor A: the main treatment effect (fixed)**\n\n* $H_0(A): \\mu_1=\\mu_2=\\ldots=\\mu_i=\\mu$\t(the population group means are all equal). That is, that the mean of population $1$ is equal to that of population $2$ and so on, and thus all population means are equal to one another - no effect of the factor on the response. If the effect of the $i$-th group is the difference between the $i$-th group mean and the mean of the first group ($\\alpha_i=\\mu_i-\\mu_1$) then the $H_0$ can alternatively be written as:\n\n* $H_0(A) : \\alpha_1=\\alpha_2=\\ldots=\\alpha_i=0$ (the effect of each group equals zero). If one or more of the $\\alpha_i$ are different from zero (the response mean for this treatment differs from the overall response mean), there is evidence that the null hypothesis is not true indicating that the factor does affect the response variable.\n\n**Factor A: the main treatment effect (random)**\n\n* $H_0(A) : \\sigma^2_{\\alpha}=0$ (population variance equals zero). There is no added variance due to all possible levels of A.\n\n**Factor B: the nested effect (random)**\n\n* $H_0(B) : \\sigma^2_{\\beta}=0$ (population variance equals zero). There is no added variance due to all possible levels of B within the (set or all possible) levels of A.\n\n**Factor B: the nested effect (fixed)**\n\n* $H_0(B): \\mu_{1(1)}=\\mu_{2(1)}=\\ldots=\\mu_{j(i)}=\\mu$\t(the population group means of B (within A) are all equal). \n\n* $H_0(B): \\beta_{1(1)}=\\beta_{2(1)}=\\ldots=\\beta_{j(i)}=0$\t(the effect of each chosen B group equals zero). \n\n## Analysis of variance\n\nAnalysis of variance sequentially partitions the total variability in the response variable into components explained by each of the factors (starting with the factors lowest down in the hierarchy - the most deeply nested) and the components unexplained by each factor. Explained variability is calculated by subtracting the amount unexplained by the factor from the amount unexplained by a reduced model that does not contain the factor. When the null hypothesis for a factor is true (no effect or added variability), the ratio of explained and unexplained components for that factor (F-ratio) should follow a theoretical F-distribution with an expected value less than 1. The appropriate unexplained residuals and therefore the appropriate F-ratios for each factor differ according to the different null hypotheses associated with different combinations of fixed and random factors in a nested linear model (see Table below).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfact_anova_table\n```\n:::\n\n\nThe corresponding `R` syntax is given below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#A fixed/random, B random (balanced)\nsummary(aov(y~A+Error(B), data))\nVarCorr(lme(y~A,random=1|B, data))\n\n#A fixed/random, B random (unbalanced)\nanova(lme(y~A,random=1|B, data), type='marginal')\n\n#A fixed/random, B fixed(balanced)\nsummary(aov(y~A+B, data))\n\n#A fixed/random, B fixed (unbalanced)\ncontrasts(data$B) <- contr.sum\nAnova(aov(y~A/B, data), type='III')\n```\n:::\n\n\n## Variance components\n\nAs previously alluded to, it can often be useful to determine the relative contribution (to explaining the unexplained variability) of each of the factors as this provides insights into the variability at each different scales. These contributions are known as **Variance components** and are estimates of the added variances due to each of the factors. For consistency with leading texts on this topic, I have included estimated variance components for various balanced nested ANOVA designs in the above table. However, variance components based on a modified version of the maximum likelihood iterative model fitting procedure (*REML*) is generally recommended as this accommodates both balanced and unbalanced designs. While there are no numerical differences in the calculations of variance components for fixed and random factors, fixed factors are interpreted very differently and arguably have little clinical meaning (other to infer relative contribution). For fixed factors, variance components estimate the variance between the means of the specific populations that are represented by the selected levels of the factor and therefore represent somewhat arbitrary and artificial populations. For random factors, variance components estimate the variance between means of all possible populations that could have been selected and thus represents the true population variance.\n\n## Assumptions\n\nAn F-distribution represents the relative frequencies of all the possible F-ratio's when a given null hypothesis is true and certain assumptions about the residuals (denominator in the F-ratio calculation) hold. Consequently, it is also important that diagnostics associated with a particular hypothesis test reflect the denominator for the appropriate F-ratio. For example, when testing the null hypothesis that there is no effect of Factor A ($H_0(A):\\alpha_i=0$) in a mixed nested ANOVA, the means of each level of Factor B are used as the replicates of Factor A. As with single factor anova, hypothesis testing for nested ANOVA assumes the residuals are:\n\n* normally distributed. Factors higher up in the hierarchy of a nested model are based on means (or means of means) of lower factors and thus the *Central Limit Theory* would predict that normality will usually be satisfied for the higher level factors. Nevertheless, boxplots using the appropriate scale of replication should be used to explore normality. Scale transformations are often useful.\n\n* equally varied. Boxplots and plots of means against variance (using the appropriate scale of replication) should be used to explore the spread of values. Residual plots should reveal no patterns. Scale transformations are often useful.\n\n* independent of one another - this requires special consideration so as to ensure that the scale at which sub-replicates are measured is still great enough to enable observations to be independent.\n\n## Unbalanced nested designs\n\nDesigns that incorporate fixed and random factors (either nested or factorial), involve F-ratio calculations in which the denominators are themselves random factors other than the overall residuals. Many statisticians argue that when such denominators are themselves not statistically significant (at the $0.25$ level), there are substantial power benefits from pooling together successive non-significant denominator terms. Thus an F-ratio for a particular factor might be recalculated after pooling together its original denominator with its denominators denominator and so on. The conservative $0.25$ is used instead of the usual 0.05 to reduce further the likelihood of Type II errors (falsely concluding an effect is non-significant - that might result from insufficient power).\n\nFor a simple completely balanced nested ANOVA, it is possible to pool together (calculate their mean) each of the sub-replicates within each nest (site) and then perform single factor ANOVA on those aggregates. Indeed, for a *balanced design*, the estimates and hypothesis for Factor A will be identical to that produced via nested ANOVA. However, if there are an unequal number of sub-replicates within each nest, then the single factor ANOVA will be less powerful that a proper nested ANOVA. *Unbalanced designs* are those designs in which sample (subsample) sizes for each level of one or more factors differ. These situations are relatively common in biological research, however such imbalance has some important implications for nested designs.\n\nFirstly, hypothesis tests are more robust to the assumptions of normality and equal variance when the design is balanced. Secondly (and arguably, more importantly), the model contrasts are not orthogonal (independent) and the sums of squares component attributed to each of the model terms cannot be calculated by simple additive partitioning of the total sums of squares. In such situations, exact F-ratios cannot be constructed (at least in theory), variance components calculations are more complicated and significance tests cannot be computed. The denominator MS in an *F-ratio* is determined by examining the expected value of the mean squares of each term in a model. Unequal sample sizes result in expected means squares for which there are no obvious logical comparators that enable the impact of an individual model term to be isolated. The severity of this issue depends on which scale of the sub-sampling hierarchy the unbalance(s) occurs as well whether the unbalance occurs in the replication of a fixed or random factor. For example, whilst unequal levels of the first nesting factor (e.g. unequal number of burn vs un-burnt sites) has no effect on F-ratio construction or hypothesis testing for the top level factor (irrespective of whether either of the factors are fixed or random), unequal sub-sampling (replication) at the level of a random (but not fixed) nesting factor will impact on the ability to construct F-ratios and variance components of all terms above it in the hierarchy. There are a number of alternative ways of dealing with unbalanced nested designs. All alternatives assume that the imbalance is not a direct result of the treatments themselves. Such outcomes are more appropriately analysed by modelling the counts of surviving observations via frequency analysis. \n\n* Split the analysis up into separate smaller simple ANOVA's each using the means of the nesting factor to reflect the appropriate scale of replication. As the resulting sums of squares components are thereby based on an aggregated dataset the analyses then inherit the procedures and requirements of single ANOVA. \n* Adopt mixed-modelling techniques.\n\nWe note that, in a Bayesian framework, issues of design balance essentially evaporate.\n\n## Linear mixed effects models\n\nAlthough the term \"mixed-effects\" can be used to refer to any design that incorporates both fixed and random predictors, its use is more commonly restricted to designs in which factors are nested or grouped within other factors. Typical examples include nested, longitudinal (measurements repeated over time) data, repeated measures and blocking designs. Furthermore, rather than basing parameter estimations on observed and expected mean squares or error strata (as outline above), mixed-effects models estimate parameters via **maximum likelihood** (ML) or **residual maximum likelihood** (REML). In so doing, mixed-effects models more appropriately handle estimation of parameters, effects and variance components of unbalanced designs (particularly for random effects). Resulting fitted (or expected) values of each level of a factor (for example, the expected population site means) are referred to as *Best Linear Unbiased Predictors* (BLUP's). As an acknowledgement that most estimated site means will be more extreme than the underlying true population means they estimate (based on the principle that smaller sample sizes result in greater chances of more extreme observations and that nested sub-replicates are also likely to be highly intercorrelated), BLUP's are less spread from the overall mean than are simple site means. In addition, mixed-effects models naturally model the \"within-block\" correlation structure that complicates many longitudinal designs.\n\nWhilst the basic concepts of mixed-effects models have been around for a long time, recent computing advances and adoptions have greatly boosted the popularity of these procedures. Linear mixed effects models are currently at the forefront of statistical development, and as such, are very much a work in progress - both in theory and in practice. Recent developments have seen a further shift away from the traditional practices associated with degrees of freedom, probability distribution and p-value calculations. The traditional approach to inference testing is to compare the fit of an alternative (full) model to a null (reduced) model (via an F-ratio). When assumptions of normality and homogeneity of variance apply, the degrees of freedom are easily computed and the F-ratio has an exact F-distribution to which it can be compared. However, this approach introduces two additional problematic assumptions when estimating fixed effects in a mixed effects model. Firstly, when estimating the effects of one factor, the parameter estimates associated with other factor(s) are assumed to be the true values of those parameters (not estimates). Whilst this assumption is reasonable when all factors are fixed, as random factors are selected such that they represent one possible set of levels drawn from an entire population of possible levels for the random factor, it is unlikely that the associated parameter estimates accurately reflect the true values. Consequently, there is not necessarily an appropriate F-distribution. Furthermore, determining the appropriate degrees of freedom (nominally, the number of independent observations on which estimates are based) for models that incorporate a hierarchical structure is only possible under very specific circumstances (such as completely balanced designs). Degrees of freedom is a somewhat arbitrary defined concept used primarily to select a theoretical probability distribution on which a statistic can be compared. Arguably, however, it is a concept that is overly simplistic for complex hierarchical designs. Most statistical applications continue to provide the \"approximate\" solutions (as did earlier versions within `R`). However, `R` linear mixed effects development leaders argue strenuously that given the above shortcomings, such approximations are variably inappropriate and are thus omitted.\n\n**Markov chain Monte Carlo** (MCMC) sampling methods provide a Bayesian-like alternative for inference testing. Markov chains use the mixed model parameter estimates to generate posterior probability distributions of each parameter from which Monte Carlo sampling methods draw a large set of parameter samples. These parameter samples can then be used to calculate *highest posterior density* (HPD) intervals (also known as Bayesian credible intervals). Such intervals indicate the interval in which there is a specified probability (typically $95$%) that the true population parameter lies. Furthermore, whilst technically against the spirit of the Bayesian philosophy, it is also possible to generate P values on which to base inferences.\n\n# Data generation\n\nImagine we has designed an experiment in which we intend to measure a response ($y$) to one of treatments (three levels; \"a1\", \"a2\" and \"a3\"). The treatments occur at a spatial scale (over an area) that far exceeds the logistical scale of sampling units (it would take too long to sample at the scale at which the treatments were applied). The treatments occurred at the scale of hectares whereas it was only feasible to sample y using 1m quadrats. Given that the treatments were naturally occurring (such as soil type), it was not possible to have more than five sites of each treatment type, yet prior experience suggested that the sites in which you intended to sample were very uneven and patchy with respect to $y$. In an attempt to account for this inter-site variability (and thus maximize the power of the test for the effect of treatment, you decided to employ a nested design in which 10 quadrats were randomly located within each of the five replicate sites per three treatments. As this section is mainly about the generation of artificial data (and not specifically about what to do with the data), understanding the actual details are optional and can be safely skipped. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plyr)\nset.seed(123)\nnTreat <- 3\nnSites <- 15\nnSitesPerTreat <- nSites/nTreat\nnQuads <- 10\nsite.sigma <- 12\nsigma <- 5\nn <- nSites * nQuads\nsites <- gl(n=nSites,k=nQuads, lab=paste0('S',1:nSites))\nA <- gl(nTreat, nSitesPerTreat*nQuads, n, labels=c('a1','a2','a3'))\na.means <- c(40,70,80)\n## the site means (treatment effects) are drawn from normal distributions\n## with means of 40, 70 and 80 and standard deviations of 12\nA.effects <- rnorm(nSites, rep(a.means,each=nSitesPerTreat),site.sigma)\n#A.effects <- a.means %*% t(model.matrix(~A, data.frame(A=gl(nTreat,nSitesPerTreat,nSites))))+rnorm(nSites,0,site.sigma)\nXmat <- model.matrix(~sites -1)\nlin.pred <- Xmat %*% c(A.effects)\n## the quadrat observations (within sites) are drawn from\n## normal distributions with means according to the site means\n## and standard deviations of 5\ny <- rnorm(n,lin.pred,sigma)\ndata.nest <- data.frame(y=y, A=A, Sites=sites,Quads=1:length(y))\nhead(data.nest)  #print out the first six rows of the data set\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA          y  A Sites Quads\nNA 1 42.20886 a1    S1     1\nNA 2 35.76354 a1    S1     2\nNA 3 23.44121 a1    S1     3\nNA 4 36.78107 a1    S1     4\nNA 5 30.91034 a1    S1     5\nNA 6 27.93517 a1    S1     6\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(data.nest, aes(y=y, x=1)) + geom_boxplot() + facet_grid(.~Sites)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Exploratory data analysis\n\n**Normality and Homogeneity of variance**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Effects of treatment\nboxplot(y~A, ddply(data.nest, ~A+Sites,numcolwise(mean, na.rm=T)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Site effects\nboxplot(y~Sites, ddply(data.nest, ~A+Sites+Quads,numcolwise(mean, na.rm=T)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n\n```{.r .cell-code}\n## with ggplot2\nggplot(ddply(data.nest, ~A+Sites,numcolwise(mean, na.rm=T)), aes(y=y, x=A)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-3.png){width=672}\n:::\n:::\n\n\n**Conclusions**:\n\n* there is no evidence that the response variable is consistently non-normal across all populations - each boxplot is approximately symmetrical.\n\n* there is no evidence that variance (as estimated by the height of the boxplots) differs between the five populations. More importantly, there is no evidence of a relationship between mean and variance - the height of boxplots does not increase with increasing position along the y-axis. Hence it there is no evidence of non-homogeneity.\n\nObvious violations could be addressed either by:\n\n* transform the scale of the response variables (to address normality, etc). Note transformations should be applied to the entire response variable (not just those populations that are skewed).\n\n# Model fitting\n\nFor non-hierarchical linear models, uniform priors on variance (standard deviation) parameters seem to work reasonably well. @gelman2006prior warns that the use of the inverse-gamma family of non-informative priors are very sensitive to ϵ particularly when variance is close to zero and this may lead to unintentionally informative priors. When the number of groups (treatments or varying/random effects) is large (more than $5$), @gelman2006prior advocated the use of either uniform or half-cauchy priors. Yet when the number of groups is low, @gelman2006prior indicates that uniform priors have a tendency to result in inflated variance estimates. Consequently, half-Cauchy priors are generally recommended for variances.\n\n**Full parameterisation**\n\n$$\ny_{ijk} \\sim N(\\mu_{ij}, \\sigma^2), \\;\\;\\; \\mu_{ij}=\\alpha_0 + \\alpha_i + \\beta_{j(i)}, \n$$\n\nwhere $\\beta_{ij)} \\sim N(0, \\sigma^2_B)$, $\\alpha_0, \\alpha_i \\sim N(0, 1000000)$, and $\\sigma^2, \\sigma^2_B \\sim \\text{Cauchy(0, 25)}$. The *full parameterisation*, shows the effects parameterisation in which there is an intercept ($\\alpha_0$) and two treatment effects ($\\alpha_i$, where $i$ is $1,2$).\n\n**Matrix parameterisation**\n\n$$\ny_{ijk} \\sim N(\\mu_{ij}, \\sigma^2), \\;\\;\\; \\mu_{ij}=\\boldsymbol \\alpha \\boldsymbol X + \\beta_{j(i)}, \n$$\n\nwhere $\\beta_{ij} \\sim N(0, \\sigma^2_B)$, $\\boldsymbol \\alpha \\sim MVN(0, 1000000)$, and $\\sigma^2, \\sigma^2_B \\sim \\text{Cauchy(0, 25)}$. The full parameterisation, shows the effects parameterisation in which there is an intercept ($\\alpha_0$) and two treatment effects ($\\alpha_i$, where $i$ is $1,2$). The *matrix parameterisation* is a compressed notation, In this parameterisation, there are three alpha parameters (one representing the mean of treatment a1, and the other two representing the treatment effects (differences between a2 and a1 and a3 and a1). In generating priors for each of these three alpha parameters, we could loop through each and define a non-informative normal prior to each (as in the Full parameterisation version). However, it turns out that it is more efficient (in terms of mixing and thus the number of necessary iterations) to define the priors from a multivariate normal distribution. This has as many means as there are parameters to estimate ($3$) and a $3\\times3$ matrix of zeros and $100$ in the diagonals.\n\n$$\n\\boldsymbol \\mu =\n  \\begin{bmatrix} 0  \\\\ 0  \\\\ 0 \\end{bmatrix}, \\;\\;\\; \\sigma^2 \\sim   \n  \\begin{bmatrix}\n   1000000 & 0 & 0 \\\\\n   0 & 1000000 & 0 \\\\\n   0 & 0 & 1000000\n   \\end{bmatrix}.\n$$\n\n**Hierarchical parameterisation**\n\n$$\ny_{ijk} \\sim N(\\beta_{i(j)}, \\sigma^2), \\;\\;\\; \\beta_{i(j)}\\sim N(\\mu_i, \\sigma^2_B),\n$$\n\nwhere $\\mu_i = \\boldsymbol \\alpha \\boldsymbol X$, $\\alpha_i \\sim N(0, 1000000)$, and $\\sigma^2, \\sigma^2_B \\sim \\text{Cauchy(0, 25)}$. In the *heirarchical parameterisation*, we are indicating two residual layers - one representing the variability in the observed data between individual observations (within sites) and the second representing the variability between site means (within the three treatments).\n\n## Full effect parameterisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelString=\"\nmodel {\n   #Likelihood\n   for (i in 1:n) {\n      y[i]~dnorm(mu[i],tau)\n      mu[i] <- alpha0 + alpha[A[i]] + beta[site[i]]\n   }\n   \n   #Priors\n   alpha0 ~ dnorm(0, 1.0E-6)\n   alpha[1] <- 0\n   for (i in 2:nA) {\n     alpha[i] ~ dnorm(0, 1.0E-6) #prior\n   }\n   for (i in 1:nSite) {\n     beta[i] ~ dnorm(0, tau.B) #prior\n   }\n   tau <- pow(sigma,-2)\n   sigma <-z/sqrt(chSq)\n   z ~ dnorm(0, .0016)I(0,)\n   chSq ~ dgamma(0.5, 0.5)\n\n   tau.B <- pow(sigma.B,-2)\n   sigma.B <-z/sqrt(chSq.B)\n   z.B ~ dnorm(0, .0016)I(0,)\n   chSq.B ~ dgamma(0.5, 0.5)\n }\n\"\n\n## write the model to a text file\nwriteLines(modelString, con = \"fullModel.txt\")\n```\n:::\n\n\nArrange the data as a list (as required by `JAGS`). As input, `JAGS` will need to be supplied with: the response variable, the predictor matrix, the number of predictors, the total number of observed items. This all needs to be contained within a list object. We will create two data lists, one for each of the hypotheses.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.nest.list <- with(data.nest,\n        list(y=y,\n                 site=as.numeric(Sites),\n         A=as.numeric(A),\n         n=nrow(data.nest),\n         nSite=length(levels(Sites)),\n                 nA = length(levels(A))\n         )\n)\n```\n:::\n\n\nDefine the nodes (parameters and derivatives) to monitor and the chain parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- c(\"alpha0\",\"alpha\",\"sigma\",\"sigma.B\")\nadaptSteps = 1000\nburnInSteps = 3000\nnChains = 2\nnumSavedSteps = 3000\nthinSteps = 1\nnIter = burnInSteps+ceiling((numSavedSteps * thinSteps)/nChains)\n```\n:::\n\n\nStart the `JAGS` model (check the model, load data into the model, specify the number of chains and compile the model). Load the `R2jags` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(R2jags)\n```\n:::\n\n\nNow run the `JAGS` code via the `R2jags` interface.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.nest.r2jags.f <- jags(data = data.nest.list, inits = NULL, parameters.to.save = params,\n    model.file = \"fullModel.txt\", n.chains = nChains, n.iter = nIter,\n    n.burnin = burnInSteps, n.thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Compiling model graph\nNA    Resolving undeclared variables\nNA    Allocating nodes\nNA Graph information:\nNA    Observed stochastic nodes: 150\nNA    Unobserved stochastic nodes: 22\nNA    Total graph size: 502\nNA \nNA Initializing model\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(data.nest.r2jags.f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Inference for Bugs model at \"fullModel.txt\", fit using jags,\nNA  2 chains, each with 4500 iterations (first 3000 discarded)\nNA  n.sims = 3000 iterations saved\nNA          mu.vect sd.vect    2.5%     25%     50%     75%   97.5%  Rhat n.eff\nNA alpha[1]   0.000   0.000   0.000   0.000   0.000   0.000   0.000 1.000     1\nNA alpha[2]  27.388   7.149  13.085  22.881  27.312  31.980  41.230 1.001  3000\nNA alpha[3]  40.839   7.083  26.936  36.251  40.800  45.412  55.107 1.002  3000\nNA alpha0    42.325   4.978  32.452  39.136  42.215  45.422  52.310 1.002  3000\nNA sigma      5.069   0.307   4.530   4.851   5.051   5.265   5.722 1.002  3000\nNA sigma.B   10.990   2.527   7.168   9.260  10.656  12.306  17.136 1.009   190\nNA deviance 909.635   5.937 899.898 905.400 908.952 913.145 923.175 1.001  3000\nNA \nNA For each parameter, n.eff is a crude measure of effective sample size,\nNA and Rhat is the potential scale reduction factor (at convergence, Rhat=1).\nNA \nNA DIC info (using the rule, pD = var(deviance)/2)\nNA pD = 17.6 and DIC = 927.3\nNA DIC is an estimate of expected predictive error (lower deviance is better).\n```\n\n\n:::\n:::\n\n\n## Matrix parameterisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelString2=\"\nmodel {\n   #Likelihood\n   for (i in 1:n) {\n      y[i]~dnorm(mu[i],tau)\n      mu[i] <- inprod(alpha[],X[i,]) + inprod(beta[], Z[i,])\n   } \n   \n   #Priors\n   alpha ~ dmnorm(a0,A0)\n   for (i in 1:nZ) {\n     beta[i] ~ dnorm(0, tau.B) #prior\n   }\n   tau <- pow(sigma,-2)\n   sigma <-z/sqrt(chSq)\n   z ~ dnorm(0, .0016)I(0,)\n   chSq ~ dgamma(0.5, 0.5)\n\n   tau.B <- pow(sigma.B,-2)\n   sigma.B <-z/sqrt(chSq.B)\n   z.B ~ dnorm(0, .0016)I(0,)\n   chSq.B ~ dgamma(0.5, 0.5)\n\n}\n\"\n\n## write the model to a text file\nwriteLines(modelString2, con = \"matrixModel.txt\")\n```\n:::\n\n\nArrange the data as a list (as required by `JAGS`). As input, `JAGS` will need to be supplied with: the response variable, the predictor matrix, the number of predictors, the total number of observed items. This all needs to be contained within a list object. We will create two data lists, one for each of the hypotheses.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA.Xmat <- model.matrix(~A,data.nest)\nZmat <- model.matrix(~-1+Sites, data.nest)\ndata.nest.list <- with(data.nest,\n        list(y=y,\n         X=A.Xmat,\n         n=nrow(data.nest),\n         Z=Zmat, nZ=ncol(Zmat),\n         a0=rep(0,3), A0=diag(3)\n         )\n)\n```\n:::\n\n\nDefine the nodes (parameters and derivatives) to monitor and the chain parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- c(\"alpha\",\"sigma\",\"sigma.B\",'beta')\nburnInSteps = 3000\nnChains = 2\nnumSavedSteps = 3000\nthinSteps = 1\nnIter = burnInSteps+ceiling((numSavedSteps * thinSteps)/nChains)\n```\n:::\n\n\nNow run the `JAGS` code via the `R2jags` interface.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.nest.r2jags.m <- jags(data = data.nest.list, inits = NULL, parameters.to.save = params,\n    model.file = \"matrixModel.txt\", n.chains = nChains, n.iter = nIter,\n    n.burnin = burnInSteps, n.thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Compiling model graph\nNA    Resolving undeclared variables\nNA    Allocating nodes\nNA Graph information:\nNA    Observed stochastic nodes: 150\nNA    Unobserved stochastic nodes: 20\nNA    Total graph size: 3231\nNA \nNA Initializing model\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(data.nest.r2jags.m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Inference for Bugs model at \"matrixModel.txt\", fit using jags,\nNA  2 chains, each with 4500 iterations (first 3000 discarded)\nNA  n.sims = 3000 iterations saved\nNA          mu.vect sd.vect    2.5%     25%     50%     75%   97.5%  Rhat n.eff\nNA alpha[1]   0.201   1.016  -1.750  -0.474   0.215   0.872   2.161 1.001  3000\nNA alpha[2]   0.082   0.972  -1.835  -0.585   0.092   0.730   1.954 1.003  2000\nNA alpha[3]   0.077   1.005  -1.867  -0.608   0.075   0.771   2.055 1.001  3000\nNA beta[1]   31.532   1.871  27.942  30.237  31.536  32.794  35.248 1.001  3000\nNA beta[2]   38.069   1.911  34.289  36.788  38.125  39.343  41.817 1.001  3000\nNA beta[3]   59.346   1.872  55.692  58.089  59.346  60.579  63.088 1.001  3000\nNA beta[4]   40.644   1.936  36.885  39.378  40.659  41.960  44.321 1.002  1400\nNA beta[5]   40.506   1.855  36.802  39.248  40.492  41.750  44.199 1.001  3000\nNA beta[6]   90.495   2.131  86.451  89.013  90.489  91.970  94.602 1.001  3000\nNA beta[7]   75.252   2.114  71.007  73.850  75.238  76.681  79.322 1.002  1200\nNA beta[8]   57.061   2.180  52.888  55.574  57.032  58.568  61.289 1.001  2400\nNA beta[9]   61.336   2.171  57.214  59.855  61.372  62.822  65.415 1.001  3000\nNA beta[10]  62.816   2.159  58.580  61.353  62.774  64.268  67.144 1.001  3000\nNA beta[11]  93.379   2.134  89.192  91.945  93.374  94.750  97.533 1.001  3000\nNA beta[12]  83.011   2.161  78.822  81.508  83.024  84.486  87.245 1.001  3000\nNA beta[13]  82.765   2.202  78.398  81.292  82.774  84.252  87.054 1.001  3000\nNA beta[14]  81.140   2.165  76.775  79.675  81.185  82.598  85.236 1.001  3000\nNA beta[15]  74.041   2.119  70.008  72.616  74.027  75.493  78.245 1.001  3000\nNA sigma      5.058   0.306   4.499   4.844   5.049   5.255   5.710 1.002  1200\nNA sigma.B   68.791  13.133  48.825  59.338  66.869  75.995  98.963 1.002  3000\nNA deviance 909.431   6.235 899.560 905.043 908.621 913.008 923.865 1.003   810\nNA \nNA For each parameter, n.eff is a crude measure of effective sample size,\nNA and Rhat is the potential scale reduction factor (at convergence, Rhat=1).\nNA \nNA DIC info (using the rule, pD = var(deviance)/2)\nNA pD = 19.4 and DIC = 928.8\nNA DIC is an estimate of expected predictive error (lower deviance is better).\n```\n\n\n:::\n:::\n\n\n## Hierarchical parameterisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelString3=\"\nmodel {\n   #Likelihood (esimating site means (gamma.site)\n   for (i in 1:n) {\n      y[i]~dnorm(quad.means[i],tau)\n      quad.means[i] <- gamma.site[site[i]]\n   }\n   for (i in 1:s) {\n      gamma.site[i] ~ dnorm(site.means[i], tau.site)\n      site.means[i] <- inprod(beta[],A.Xmat[i,])\n   }\n   #Priors\n   for (i in 1:a) {\n     beta[i] ~ dnorm(0, 1.0E-6) #prior\n   }\n   tau <- pow(sigma,-2)\n   sigma <-z/sqrt(chSq)\n   z ~ dnorm(0, .0016)I(0,)\n   chSq ~ dgamma(0.5, 0.5)\n\n   tau.B <- pow(sigma.B,-2)\n   sigma.B <-z/sqrt(chSq.B)\n   z.B ~ dnorm(0, .0016)I(0,)\n   chSq.B ~ dgamma(0.5, 0.5)\n\n   tau.site <- pow(sigma.site,-2)\n   sigma.site <-z/sqrt(chSq.site)\n   z.site ~ dnorm(0, .0016)I(0,)\n   chSq.site ~ dgamma(0.5, 0.5)\n }\n\"\n\n## write the model to a text file\nwriteLines(modelString3, con = \"hierarchicalModel.txt\")\n```\n:::\n\n\nArrange the data as a list (as required by `JAGS`). As input, `JAGS` will need to be supplied with: the response variable, the predictor matrix, the number of predictors, the total number of observed items. This all needs to be contained within a list object. We will create two data lists, one for each of the hypotheses.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA.Xmat <- model.matrix(~A,ddply(data.nest,~Sites,catcolwise(unique)))\ndata.nest.list <- with(data.nest,\n        list(y=y,\n                 site=Sites,\n         A.Xmat= A.Xmat,\n         n=nrow(data.nest),\n         s=length(levels(Sites)),\n                 a = ncol(A.Xmat)\n         )\n)\n```\n:::\n\n\nDefine the nodes (parameters and derivatives) to monitor and the chain parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- c(\"beta\",\"sigma\",\"sigma.site\")\nburnInSteps = 3000\nnChains = 2\nnumSavedSteps = 3000\nthinSteps = 1\nnIter = burnInSteps+ceiling((numSavedSteps * thinSteps)/nChains)\n```\n:::\n\n\nNow run the `JAGS` code via the `R2jags` interface.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.nest.r2jags.h <- jags(data = data.nest.list, inits = NULL, parameters.to.save = params,\n    model.file = \"hierarchicalModel.txt\", n.chains = nChains, n.iter = nIter,\n    n.burnin = burnInSteps, n.thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Compiling model graph\nNA    Resolving undeclared variables\nNA    Allocating nodes\nNA Graph information:\nNA    Observed stochastic nodes: 150\nNA    Unobserved stochastic nodes: 24\nNA    Total graph size: 406\nNA \nNA Initializing model\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(data.nest.r2jags.h)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Inference for Bugs model at \"hierarchicalModel.txt\", fit using jags,\nNA  2 chains, each with 4500 iterations (first 3000 discarded)\nNA  n.sims = 3000 iterations saved\nNA            mu.vect sd.vect    2.5%     25%     50%     75%   97.5%  Rhat n.eff\nNA beta[1]     42.139   4.991  32.186  38.913  42.226  45.346  51.751 1.001  3000\nNA beta[2]     27.611   6.859  13.692  23.437  27.617  31.993  41.118 1.001  3000\nNA beta[3]     41.048   7.032  26.813  36.805  41.067  45.316  55.566 1.002  1200\nNA sigma        5.058   0.315   4.483   4.841   5.036   5.257   5.763 1.001  3000\nNA sigma.site  10.889   2.386   7.235   9.269  10.578  12.125  16.695 1.005  3000\nNA deviance   909.557   6.168 899.915 905.154 908.708 913.153 923.686 1.001  1900\nNA \nNA For each parameter, n.eff is a crude measure of effective sample size,\nNA and Rhat is the potential scale reduction factor (at convergence, Rhat=1).\nNA \nNA DIC info (using the rule, pD = var(deviance)/2)\nNA pD = 19.0 and DIC = 928.6\nNA DIC is an estimate of expected predictive error (lower deviance is better).\n```\n\n\n:::\n:::\n\n\nIf you want to include finite-population standard deviations in the model you can use the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelString4=\"\nmodel {\n   #Likelihood (esimating site means (gamma.site)\n   for (i in 1:n) {\n      y[i]~dnorm(quad.means[i],tau)\n      quad.means[i] <- gamma.site[site[i]]\n      y.err[i]<- quad.means[i]-y[i]\n   }\n   for (i in 1:s) {\n      gamma.site[i] ~ dnorm(site.means[i], tau.site)\n      site.means[i] <- inprod(beta[],A.Xmat[i,])\n      site.err[i] <- site.means[i] - gamma.site[i]\n   }\n   #Priors\n   for (i in 1:a) {\n     beta[i] ~ dnorm(0, 1.0E-6) #prior\n   }\n   tau <- pow(sigma,-2)\n   sigma <-z/sqrt(chSq)\n   z ~ dnorm(0, .0016)I(0,)\n   chSq ~ dgamma(0.5, 0.5)\n\n   tau.site <- pow(sigma.site,-2)\n   sigma.site <-z/sqrt(chSq.site)\n   z.site ~ dnorm(0, .0016)I(0,)\n   chSq.site ~ dgamma(0.5, 0.5)\n   \n   sd.y <- sd(y.err)\n   sd.site <- sd(site.err)\n   sd.A <- sd(beta)\n }\n\"\n\n## write the model to a text file\nwriteLines(modelString4, con = \"SDModel.txt\")\n\n#data list\nA.Xmat <- model.matrix(~A,ddply(data.nest,~Sites,catcolwise(unique)))\ndata.nest.list <- with(data.nest,\n        list(y=y,\n                 site=Sites,\n         A.Xmat= A.Xmat,\n         n=nrow(data.nest),\n         s=length(levels(Sites)),\n                 a = ncol(A.Xmat)\n         )\n)\n\n#parameters and chain details\nparams <- c(\"beta\",\"sigma\",\"sd.y\",'sd.site','sd.A','sigma.site')\nadaptSteps = 1000\nburnInSteps = 3000\nnChains = 2\nnumSavedSteps = 3000\nthinSteps = 1\nnIter = burnInSteps+ceiling((numSavedSteps * thinSteps)/nChains)\n\ndata.nest.r2jags.SD <- jags(data = data.nest.list, inits = NULL, parameters.to.save = params,\n    model.file = \"SDModel.txt\", n.chains = nChains, n.iter = nIter,\n    n.burnin = burnInSteps, n.thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Compiling model graph\nNA    Resolving undeclared variables\nNA    Allocating nodes\nNA Graph information:\nNA    Observed stochastic nodes: 150\nNA    Unobserved stochastic nodes: 22\nNA    Total graph size: 571\nNA \nNA Initializing model\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(data.nest.r2jags.SD)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Inference for Bugs model at \"SDModel.txt\", fit using jags,\nNA  2 chains, each with 4500 iterations (first 3000 discarded)\nNA  n.sims = 3000 iterations saved\nNA            mu.vect sd.vect    2.5%     25%     50%     75%   97.5%  Rhat n.eff\nNA beta[1]     42.336   5.027  32.564  39.187  42.338  45.373  52.570 1.004   420\nNA beta[2]     27.417   7.290  12.457  22.904  27.308  31.955  42.039 1.001  2100\nNA beta[3]     40.862   7.164  26.163  36.386  40.920  45.444  55.173 1.007   770\nNA sd.A        10.042   4.276   2.657   7.162   9.646  12.369  19.900 1.001  2200\nNA sd.site     10.592   1.057   9.214   9.909  10.354  11.029  13.276 1.010   280\nNA sd.y         4.999   0.095   4.852   4.929   4.987   5.058   5.219 1.003   770\nNA sigma        5.047   0.309   4.489   4.830   5.029   5.257   5.705 1.005   310\nNA sigma.site  11.003   2.465   7.419   9.295  10.610  12.282  16.704 1.004   480\nNA deviance   909.411   6.011 899.576 904.938 908.750 913.034 922.925 1.003   630\nNA \nNA For each parameter, n.eff is a crude measure of effective sample size,\nNA and Rhat is the potential scale reduction factor (at convergence, Rhat=1).\nNA \nNA DIC info (using the rule, pD = var(deviance)/2)\nNA pD = 18.0 and DIC = 927.5\nNA DIC is an estimate of expected predictive error (lower deviance is better).\n```\n\n\n:::\n:::\n\n\nCalculate $R^2$ from the posterior of the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.nest.mcmc.listSD <- as.mcmc(data.nest.r2jags.SD)\n\nXmat <- model.matrix(~A, data.nest)\ncoefs <- data.nest.r2jags.SD$BUGSoutput$sims.list[['beta']]\nfitted <- coefs %*% t(Xmat)\nX.var <- aaply(fitted,1,function(x){var(x)})\nZ.var <- data.nest.r2jags.SD$BUGSoutput$sims.list[['sd.site']]^2\nR.var <- data.nest.r2jags.SD$BUGSoutput$sims.list[['sd.y']]^2\nR2.marginal <- (X.var)/(X.var+Z.var+R.var)\nR2.marginal <- data.frame(Mean=mean(R2.marginal), Median=median(R2.marginal), HPDinterval(as.mcmc(R2.marginal)))\nR2.conditional <- (X.var+Z.var)/(X.var+Z.var+R.var)\nR2.conditional <- data.frame(Mean=mean(R2.conditional),\n   Median=median(R2.conditional), HPDinterval(as.mcmc(R2.conditional)))\nR2.site <- (Z.var)/(X.var+Z.var+R.var)\nR2.site <- data.frame(Mean=mean(R2.site), Median=median(R2.site), HPDinterval(as.mcmc(R2.site)))\nR2.res<-(R.var)/(X.var+Z.var+R.var)\nR2.res <- data.frame(Mean=mean(R2.res), Median=median(R2.res), HPDinterval(as.mcmc(R2.res)))\n\nrbind(R2.site=R2.site, R2.marginal=R2.marginal, R2.res=R2.res, R2.conditional=R2.conditional)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA                      Mean    Median      lower      upper\nNA R2.site        0.26437322 0.2428822 0.16881028 0.41958555\nNA R2.marginal    0.67674004 0.6992418 0.49930501 0.78437310\nNA R2.res         0.05888674 0.0584191 0.03459529 0.08514432\nNA R2.conditional 0.94111326 0.9415809 0.91485568 0.96540471\n```\n\n\n:::\n:::\n\n\n## Graphical summaries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewdata <- with(data.nest, data.frame(A=levels(A)))\nXmat <- model.matrix(~A, newdata)\ncoefs <- data.nest.r2jags.m$BUGSoutput$sims.list[['alpha']]\nfit <- coefs %*% t(Xmat)\nnewdata <- cbind(newdata,\n   adply(fit, 2, function(x) {\n          data.frame(Mean=mean(x), Median=median(x), HPDinterval(as.mcmc(x)),\n             HPDinterval(as.mcmc(x), p=0.68))\n   })\n)\n\n\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(grid)\np1 <- ggplot(newdata, aes(y=Median, x=A)) +\n  geom_errorbar(aes(ymin=lower, ymax=upper), width=0.01, size=1) +\n  geom_errorbar(aes(ymin=lower.1, ymax=upper.1), width=0, size=2) +\n  geom_point(size=4, shape=21, fill='white')+\n  scale_y_continuous('Y')+\n  scale_x_discrete('X')+\n  theme_classic()+\n  theme(axis.title.y=element_text(vjust=2, size=rel(1.25)),\n        axis.title.x=element_text(vjust=-2, size=rel(1.25)),\n        plot.margin=unit(c(0.5,0.5,2,2), 'lines')\n  )\n\np1\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n# Data generation - second example\n\nNow imagine a similar experiment in which we intend to measure a response ($y$) to one of treatments (three levels; \"a1\", \"a2\" and \"a3\"). As with the previous design, we decided to establish a nested design in which there are sub-replicate ($1$m Quadrats) within each Site. In the current design, we have decided to further sub-replicate. Within each of the $5$ Quadrats, we are going to randomly place $2\\times10$cm pit traps. Now we have Sites nested within Treatments, Quadrats nested within Sites AND, Pits nested within Sites. The latter of these (Pits nested within Sites) are the observations ($y$). As this section is mainly about the generation of artificial data (and not specifically about what to do with the data), understanding the actual details are optional and can be safely skipped. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nnTreat <- 3\nnSites <- 15\nnSitesPerTreat <- nSites/nTreat\nnQuads <- 5\nnPits <- 2\nsite.sigma <- 10 # sd within between sites within treatment\nquad.sigma <- 10\nsigma <- 7.5\nn <- nSites * nQuads * nPits\nsites <- gl(n=nSites,n/nSites,n, lab=paste(\"site\",1:nSites))\nA <- gl(nTreat, n/nTreat, n, labels=c('a1','a2','a3'))\na.means <- c(40,70,80)\n\n#A<-gl(nTreat,nSites/nTreat,nSites,labels=c('a1','a2','a3'))\na<-gl(nTreat,1,nTreat,labels=c('a1','a2','a3'))\na.X <- model.matrix(~a, expand.grid(a))\na.eff <- as.vector(solve(a.X,a.means))\nsite.means <- rnorm(nSites,a.X %*% a.eff,site.sigma)\n\nA <- gl(nTreat,nSites/nTreat,nSites,labels=c('a1','a2','a3'))\nA.X <- model.matrix(~A, expand.grid(A))\n#a.X <- model.matrix(~A, expand.grid(A=gl(nTreat,nSites/nTreat,nSites,labels=c('a1','a2','a3'))))\nsite.means <- rnorm(nSites,A.X %*% a.eff,site.sigma)\n\nSITES <- gl(nSites,(nSites*nQuads)/nSites,nSites*nQuads,labels=paste('site',1:nSites))\nsites.X <- model.matrix(~SITES-1)\nquad.means <- rnorm(nSites*nQuads,sites.X %*% site.means,quad.sigma)\n\n#SITES <- gl(nSites,1,nSites,labels=paste('site',1:nSites))\n#sites.X <- model.matrix(~SITES-1)\n#quad.means <- rnorm(nSites*nQuads,sites.X %*% site.means,quad.sigma)\n\nQUADS <- gl(nSites*nQuads,n/(nSites*nQuads),n,labels=paste('quad',1:(nSites*nQuads)))\nquads.X <- model.matrix(~QUADS-1)\n#quads.eff <- as.vector(solve(quads.X,quad.means))\n#pit.means <- rnorm(n,quads.eff %*% t(quads.X),sigma)\npit.means <- rnorm(n,quads.X %*% quad.means,sigma)\n\nPITS <- gl(nPits*nSites*nQuads,1, n, labels=paste('pit',1:(nPits*nSites*nQuads)))\ndata.nest1<-data.frame(Pits=PITS,Quads=QUADS,Sites=rep(SITES,each=2), A=rep(A,each=nQuads*nPits),y=pit.means)\n#data.nest1<-data.nest1[order(data.nest1$A,data.nest1$Sites,data.nest1$Quads),]\nhead(data.nest1)  #print out the first six rows of the data set\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA    Pits  Quads  Sites  A        y\nNA 1 pit 1 quad 1 site 1 a1 61.79607\nNA 2 pit 2 quad 1 site 1 a1 56.24699\nNA 3 pit 3 quad 2 site 1 a1 42.40885\nNA 4 pit 4 quad 2 site 1 a1 52.06672\nNA 5 pit 5 quad 3 site 1 a1 73.71286\nNA 6 pit 6 quad 3 site 1 a1 62.50529\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data.nest1, aes(y=y, x=1)) + geom_boxplot() + facet_grid(.~Quads)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## Exploratory data analysis\n\n**Normality and Homogeneity of variance**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Effects of treatment\nboxplot(y~A, ddply(data.nest1, ~A+Sites,numcolwise(mean, na.rm=T)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Site effects\nboxplot(y~Sites, ddply(data.nest1, ~A+Sites+Quads,numcolwise(mean, na.rm=T)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#Quadrat effects\nboxplot(y~Quads, ddply(data.nest1, ~A+Sites+Quads+Pits,numcolwise(mean, na.rm=T)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-3.png){width=672}\n:::\n:::\n\n\n**Conclusions**:\n\n* there is no evidence that the response variable is consistently non-normal across all populations - each boxplot is approximately symmetrical.\n\n* there is no evidence that variance (as estimated by the height of the boxplots) differs between the five populations. More importantly, there is no evidence of a relationship between mean and variance - the height of boxplots does not increase with increasing position along the $y$-axis. Hence it there is no evidence of non-homogeneity.\n\n* it is a little difficult to assess normality/homogeneity of variance of quadrats since there are only two pits per quadrat. Nevertheless, there is no suggestion that variance increases with increasing mean.\n\nObvious violations could be addressed either by:\n\n* transform the scale of the response variables (to address normality, etc). Note transformations should be applied to the entire response variable (not just those populations that are skewed).\n\n# Model fitting\n\n## Frequentist for comparison\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nlme)\nd.lme <- lme(y ~ A, random=~1|Sites/Quads,data=data.nest1)\nsummary(d.lme)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Linear mixed-effects model fit by REML\nNA   Data: data.nest1 \nNA        AIC      BIC   logLik\nNA   1137.994 1155.937 -562.997\nNA \nNA Random effects:\nNA  Formula: ~1 | Sites\nNA         (Intercept)\nNA StdDev:    10.38249\nNA \nNA  Formula: ~1 | Quads %in% Sites\nNA         (Intercept) Residual\nNA StdDev:    8.441617 7.161177\nNA \nNA Fixed effects:  y ~ A \nNA                Value Std.Error DF  t-value p-value\nNA (Intercept) 41.38646  5.043341 75 8.206159  0.0000\nNA Aa2         21.36271  7.132361 12 2.995180  0.0112\nNA Aa3         39.14584  7.132361 12 5.488482  0.0001\nNA  Correlation: \nNA     (Intr) Aa2   \nNA Aa2 -0.707       \nNA Aa3 -0.707  0.500\nNA \nNA Standardized Within-Group Residuals:\nNA         Min          Q1         Med          Q3         Max \nNA -2.11852502 -0.54600753 -0.03428581  0.53382436  2.26256392 \nNA \nNA Number of Observations: 150\nNA Number of Groups: \nNA            Sites Quads %in% Sites \nNA               15               75\n```\n\n\n:::\n\n```{.r .cell-code}\nanova(d.lme)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA             numDF denDF  F-value p-value\nNA (Intercept)     1    75 446.9150  <.0001\nNA A               2    12  15.1037   5e-04\n```\n\n\n:::\n:::\n\n\n## Full effect parameterisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelString=\"\nmodel {\n   #Likelihood\n   for (i in 1:n) {\n      y[i]~dnorm(mu[i],tau)\n      mu[i] <- alpha0 + alpha[A[i]] + beta.site[site[i]] + beta.quad[quad[i]]\n   }\n   \n   #Priors\n   alpha0 ~ dnorm(0, 1.0E-6)\n   alpha[1] <- 0\n   for (i in 2:nA) {\n     alpha[i] ~ dnorm(0, 1.0E-6) #prior\n   }\n   for (i in 1:nSite) {\n     beta.site[i] ~ dnorm(0, tau.Bs) #prior\n   }\n   for (i in 1:nQuad) {\n     beta.quad[i] ~ dnorm(0, tau.Bq) #prior\n   }\n   tau <- pow(sigma,-2)\n   sigma <-z/sqrt(chSq)\n   z ~ dnorm(0, .0016)I(0,)\n   chSq ~ dgamma(0.5, 0.5)\n\n   tau.Bs <- pow(sigma.Bs,-2)\n   sigma.Bs <-z/sqrt(chSq.Bs)\n   z.Bs ~ dnorm(0, .0016)I(0,)\n   chSq.Bs ~ dgamma(0.5, 0.5)\n\n   tau.Bq <- pow(sigma.Bq,-2)\n   sigma.Bq <-z/sqrt(chSq.Bq)\n   z.Bq ~ dnorm(0, .0016)I(0,)\n   chSq.Bq ~ dgamma(0.5, 0.5)\n\n }\n\"\n\n## write the model to a text file\nwriteLines(modelString, con = \"fullModel2.txt\")\n\ndata.nest.list <- with(data.nest1,\n        list(y=y,\n                 site=as.numeric(Sites),\n         A=as.numeric(A),\n         n=nrow(data.nest1),\n         nSite=length(levels(Sites)),\n                 nA = length(levels(A)),\n         nQuad=length(levels(Quads)),\n                 quad = as.numeric(Quads)\n         )\n)\n\nparams <- c(\"alpha0\",\"alpha\",\"sigma\",\"sigma.Bs\",\"sigma.Bq\")\nburnInSteps = 3000\nnChains = 2\nnumSavedSteps = 3000\nthinSteps = 1\nnIter = burnInSteps+ceiling((numSavedSteps * thinSteps)/nChains)\n\ndata.nest.r2jags.f2 <- jags(data = data.nest.list, inits = NULL, parameters.to.save = params,\n    model.file = \"fullModel2.txt\", n.chains = nChains, n.iter = nIter,\n    n.burnin = burnInSteps, n.thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Compiling model graph\nNA    Resolving undeclared variables\nNA    Allocating nodes\nNA Graph information:\nNA    Observed stochastic nodes: 150\nNA    Unobserved stochastic nodes: 99\nNA    Total graph size: 793\nNA \nNA Initializing model\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(data.nest.r2jags.f2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Inference for Bugs model at \"fullModel2.txt\", fit using jags,\nNA  2 chains, each with 4500 iterations (first 3000 discarded)\nNA  n.sims = 3000 iterations saved\nNA           mu.vect sd.vect    2.5%      25%      50%      75%    97.5%  Rhat\nNA alpha[1]    0.000   0.000   0.000    0.000    0.000    0.000    0.000 1.000\nNA alpha[2]   21.147   7.532   6.252   16.137   21.140   25.968   35.890 1.001\nNA alpha[3]   38.985   7.635  23.341   34.130   39.120   43.879   53.757 1.001\nNA alpha0     41.541   5.460  30.677   37.967   41.659   45.032   52.383 1.001\nNA sigma       7.294   0.604   6.238    6.870    7.264    7.664    8.580 1.003\nNA sigma.Bq    8.433   1.132   6.355    7.650    8.378    9.175   10.757 1.005\nNA sigma.Bs   10.779   2.673   6.704    8.951   10.409   12.219   17.127 1.017\nNA deviance 1020.495  17.724 988.898 1007.948 1019.500 1032.389 1056.708 1.005\nNA          n.eff\nNA alpha[1]     1\nNA alpha[2]  3000\nNA alpha[3]  3000\nNA alpha0    3000\nNA sigma      970\nNA sigma.Bq   420\nNA sigma.Bs   100\nNA deviance   510\nNA \nNA For each parameter, n.eff is a crude measure of effective sample size,\nNA and Rhat is the potential scale reduction factor (at convergence, Rhat=1).\nNA \nNA DIC info (using the rule, pD = var(deviance)/2)\nNA pD = 156.8 and DIC = 1177.3\nNA DIC is an estimate of expected predictive error (lower deviance is better).\n```\n\n\n:::\n:::\n\n\n## Matrix parameterisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelString2=\"\nmodel {\n   #Likelihood\n   for (i in 1:n) {\n      y[i]~dnorm(mu[i],tau)\n      mu[i] <- inprod(alpha[], X[i,]) + inprod(beta.site[],Z.site[i,]) + inprod(beta.quad[],Z.quad[i,])\n      y.err[i] <- y[i]-mu[i]\n   }\n   \n   #Priors\n   for (i in 1:nX) {\n     alpha[i] ~ dnorm(0, 1.0E-6) #prior\n   }\n   for (i in 1:nSite) {\n     beta.site[i] ~ dnorm(0, tau.Bs) #prior\n   }\n   for (i in 1:nQuad) {\n     beta.quad[i] ~ dnorm(0, tau.Bq) #prior\n   }\n   tau <- pow(sigma,-2)\n   sigma <-z/sqrt(chSq)\n   z ~ dnorm(0, .0016)I(0,)\n   chSq ~ dgamma(0.5, 0.5)\n\n   tau.Bs <- pow(sigma.Bs,-2)\n   sigma.Bs <-z/sqrt(chSq.Bs)\n   z.Bs ~ dnorm(0, .0016)I(0,)\n   chSq.Bs ~ dgamma(0.5, 0.5)\n\n   tau.Bq <- pow(sigma.Bq,-2)\n   sigma.Bq <-z/sqrt(chSq.Bq)\n   z.Bq ~ dnorm(0, .0016)I(0,)\n   chSq.Bq ~ dgamma(0.5, 0.5)\n\n   sd.res <- sd(y.err[])\n   sd.site <- sd(beta.site[])\n   sd.quad <- sd(beta.quad[])   \n }\n\"\n\n## write the model to a text file\nwriteLines(modelString2, con = \"matrixModel2.txt\")\n\nXmat <- model.matrix(~A, data=data.nest1)\nZsite <- model.matrix(~-1+Sites, data=data.nest1)\nZquad <- model.matrix(~-1+Quads, data=data.nest1)\n\ndata.nest.list <- with(data.nest1,\n        list(y=y,\n         n=nrow(data.nest1),\n                 X=Xmat, nX=ncol(Xmat),\n         Z.site=Zsite, nSite=ncol(Zsite),\n                 Z.quad=Zquad, nQuad=ncol(Zquad)\n         )\n)\n\nparams <- c(\"alpha\",\"sigma\",\"sigma.Bs\",\"sigma.Bq\",'sd.res','sd.site','sd.quad')\nburnInSteps = 3000\nnChains = 2\nnumSavedSteps = 3000\nthinSteps = 1\nnIter = burnInSteps+ceiling((numSavedSteps * thinSteps)/nChains)\n\ndata.nest.r2jags.m2 <- jags(data = data.nest.list, inits = NULL, parameters.to.save = params,\n    model.file = \"matrixModel2.txt\", n.chains = nChains, n.iter = nIter,\n    n.burnin = burnInSteps, n.thin = thinSteps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Compiling model graph\nNA    Resolving undeclared variables\nNA    Allocating nodes\nNA Graph information:\nNA    Observed stochastic nodes: 150\nNA    Unobserved stochastic nodes: 99\nNA    Total graph size: 14993\nNA \nNA Initializing model\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(data.nest.r2jags.m2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA Inference for Bugs model at \"matrixModel2.txt\", fit using jags,\nNA  2 chains, each with 4500 iterations (first 3000 discarded)\nNA  n.sims = 3000 iterations saved\nNA           mu.vect sd.vect    2.5%      25%      50%      75%    97.5%  Rhat\nNA alpha[1]   41.247   5.438  30.494   37.721   41.227   44.692   52.262 1.002\nNA alpha[2]   21.535   7.824   6.537   16.541   21.439   26.473   37.416 1.003\nNA alpha[3]   39.276   7.723  24.165   34.357   39.319   44.191   54.637 1.001\nNA sd.quad     8.427   0.828   6.866    7.889    8.420    8.956   10.131 1.001\nNA sd.res      7.221   0.420   6.500    6.924    7.186    7.486    8.137 1.010\nNA sd.site    10.263   1.703   7.202    9.180   10.187   11.240   13.917 1.002\nNA sigma       7.261   0.598   6.189    6.845    7.209    7.631    8.540 1.010\nNA sigma.Bq    8.514   1.064   6.557    7.776    8.454    9.189   10.801 1.001\nNA sigma.Bs   10.703   2.802   6.379    8.805   10.283   12.108   17.304 1.001\nNA deviance 1019.366  17.429 987.783 1007.166 1018.196 1030.618 1056.340 1.010\nNA          n.eff\nNA alpha[1]  3000\nNA alpha[2]  3000\nNA alpha[3]  2500\nNA sd.quad   3000\nNA sd.res     150\nNA sd.site   3000\nNA sigma      160\nNA sigma.Bq  3000\nNA sigma.Bs  3000\nNA deviance   160\nNA \nNA For each parameter, n.eff is a crude measure of effective sample size,\nNA and Rhat is the potential scale reduction factor (at convergence, Rhat=1).\nNA \nNA DIC info (using the rule, pD = var(deviance)/2)\nNA pD = 151.0 and DIC = 1170.4\nNA DIC is an estimate of expected predictive error (lower deviance is better).\n```\n\n\n:::\n:::\n\n\nIf we use the `JAGS` matrix parameterisation model from above, the `JAGS` model is already complete (as we defined the sd components in that model already).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.nest1.mcmc.listSD <- as.mcmc(data.nest.r2jags.m2)\n\nXmat <- model.matrix(~A, data.nest1)\ncoefs <- data.nest.r2jags.m2$BUGSoutput$sims.list[['alpha']]\nfitted <- coefs %*% t(Xmat)\nX.var <- aaply(fitted,1,function(x){var(x)})\nZ.var <- data.nest.r2jags.m2$BUGSoutput$sims.list[['sd.site']]^2\nR.var <- data.nest.r2jags.m2$BUGSoutput$sims.list[['sd.res']]^2\nR2.marginal <- (X.var)/(X.var+Z.var+R.var)\nR2.marginal <- data.frame(Mean=mean(R2.marginal), Median=median(R2.marginal), HPDinterval(as.mcmc(R2.marginal)))\nR2.conditional <- (X.var+Z.var)/(X.var+Z.var+R.var)\nR2.conditional <- data.frame(Mean=mean(R2.conditional),\n   Median=median(R2.conditional), HPDinterval(as.mcmc(R2.conditional)))\nR2.site <- (Z.var)/(X.var+Z.var+R.var)\nR2.site <- data.frame(Mean=mean(R2.site), Median=median(R2.site), HPDinterval(as.mcmc(R2.site)))\nR2.res<-(R.var)/(X.var+Z.var+R.var)\nR2.res <- data.frame(Mean=mean(R2.res), Median=median(R2.res), HPDinterval(as.mcmc(R2.res)))\n\nrbind(R2.site=R2.site, R2.marginal=R2.marginal, R2.res=R2.res, R2.conditional=R2.conditional)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNA                     Mean    Median     lower     upper\nNA R2.site        0.2537842 0.2373232 0.1145934 0.4450797\nNA R2.marginal    0.6199972 0.6408875 0.4077973 0.7873383\nNA R2.res         0.1262186 0.1233096 0.0646023 0.1907540\nNA R2.conditional 0.8737814 0.8766904 0.8092460 0.9353977\n```\n\n\n:::\n:::\n\n\n# References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}