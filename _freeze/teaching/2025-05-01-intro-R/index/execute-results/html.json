{
  "hash": "fa790a458fcaae3301974c3af71dbd46",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to R\"\ndescription: \"\"\nauthor:\n  - name: Andrea Gabrio\n    url: https://angabrio.github.io/agabriosite2/\n    orcid: 0000-0002-7650-4534\n    email: a.gabrio@maastrichtuniversity.nl\n    corresponding: true    \n    affiliation: Maastricht University\n    affiliation-url: https://www.maastrichtuniversity.nl/research/methodology-and-statistics\ndate: 2025-05-01\ncategories: [Quarto, R, Teaching, Software, Statistics, RMT1005] # self-defined categories\nimage: featured.png\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\nkeywords:\n  - Software\n  - Statistics\n  - R\n  - Teaching\n  - RMT1005\nbibliography: ref.bib\nnocite: |\n  @rsoftware, @wickham2017r, @field2012discovering, @kabacoff2022r, @crawley2012r\n---\n\n\n\n# What is `R`?\n\n`R` is a computer statistics software based on the programming language `S`, also known as \"function language\", with many \"in-built\" statistical commands and an environment for writing your own functions. Among the key advantages that make `R` a useful and appealing choice with respect to other statistical packages include: its flexibility, simplicity, and quality of graphical display. In addition, `R` is a freely-available software which may be downloaded from the [website](https://www.r-project.org/).\n\n## Starting `R`\n\nAfter downloading and installing the software, to start `R` select its icon in the list of applications on your computer and launch it by clicking on `R x.y.z` or `R xg4 x.y.z`, where `x.y.z.` is the version number (e.g. `4.2.2`). A large window opens, headed `RGui`, within which there is a small window, headed `R console`, containing some text followed by the prompt `>`, which indicates that `R` is waiting for you to give it some commands.\n\n## Getting out\n\nTo stop `R`, type `q()` at the prompt and press the `<Return>` key and, in response to the question `Save workspace image?`, answer `No`.\n\n# Simple manipulations: numbers and vectors\n\nElementary `R` commands are either\n\n  - *Expression*: command to display the result of a calculation, which is not retained in the computer memory.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of an expression\n3 + 7\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n  - *Assignment*: command to pass the result of a calculation to a variable name which is stored in the computer memory (but the result is not necessarily printed out on the screen).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of an assignment\nx <- 3 + 7\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\nNote the use of the assignment operator `<-` above, which reads as an arrow pointing to the object `x` so that the command line above could be interpreted as \"take the value of the expression `3 + 7` and put it in `x`\". You can also achieve the same result using the operator `=` instead of `<-`. \n\n## Stored objects\n\nAll assigned variables, or any other `R` objects, are automatically stored by the computer in your `R` workspace until you close your `R` session. When this is ended, e.g. by typing `q()`, `R` gives you the option to save your workspace for future use. If you save it, all objects will remain in your computer memory until overwritten or explicitly deleted using the command `rm()`. \n\nTo see what variables are stored, type `ls()` or `objects()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of saving/deleting variables from R workspace\nx <- 10\ny <- 6.78\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x\" \"y\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(x)\nobjects()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"y\"\n```\n\n\n:::\n:::\n\n\n\n# Syntax for `R` commands\n\nAll `R` commands, e.g. `ls()` or `rm()`, are followed by parentheses which may or may not contain additional information for the function. Writing a command name without parentheses simply makes `R` write out the `S` source code for the function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of function source code\nrm(y)\nrm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (..., list = character(), pos = -1, envir = as.environment(pos), \n    inherits = FALSE) \n{\n    if (...length()) {\n        dots <- match.call(expand.dots = FALSE)$...\n        if (!all(vapply(dots, function(x) is.symbol(x) || is.character(x), \n            NA, USE.NAMES = FALSE))) \n            stop(\"... must contain names or character strings\")\n        list <- .Primitive(\"c\")(list, vapply(dots, as.character, \n            \"\"))\n    }\n    .Internal(remove(list, envir, inherits))\n}\n<bytecode: 0x0000023db845c610>\n<environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n\n## Creating vectors in `R`\n\nThe command `c()` creates `R` vectors.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a vector\nx <- c(3,5,6,3,4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 5 6 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- c(x,10,x)\n```\n:::\n\n\n\nIf you make a mistake while typing, you can use the up arrow key to recall your previous commands and correct them, so that you do not have to type everything again from scratch. Sometimes we may want to create sequences by using the expression `1:n`, which denotes the sequence `1,2,...,n-1,n`. More generally, `seq(i,j,k)` is a sequence from `i` to `j` in steps of `k`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a sequence\nz <- 1:7\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6 7\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(4,20,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  9 14 19\n```\n\n\n:::\n:::\n\n\n\n## `R` vector arithmetic\n\n`R` uses `+,-,*,/` for the basic arithmetic operations, and `^` for exponentiation. Vector operations are done element by element, with recycling for short vectors if required.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of vector arithmetic\nx <- c(4,16)\ny <- c(1,2,4,8)\n2*x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  8 32\n```\n\n\n:::\n\n```{.r .cell-code}\ny^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4 16 64\n```\n\n\n:::\n\n```{.r .cell-code}\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5 18  8 24\n```\n\n\n:::\n\n```{.r .cell-code}\nx/y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 8 1 2\n```\n\n\n:::\n:::\n\n\n\n## Operator precedence\n\nIt is important to understand the order in which operations are done by `R`. With the standard arithmetic operations, `R` follows the usual rules: `^` first, then `*` and `/`, and finally `+` and `-`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of combined operations\n4+2*3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\n2^2/4-5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -4\n```\n\n\n:::\n:::\n\n\n\nNote, however, that it is difficult to read the commands above and, in general, it is good practice to use brackets to make explicit the order in which you want the calculations to be done.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of vector arithmetic\n(4+2)*3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n\n```{.r .cell-code}\n((2)^2)/4-5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -4\n```\n\n\n:::\n:::\n\n\n\nThis way, not only the commands are easier to read but it also ensures that `R` is not making any decisions for you. In some cases, the decisions left to `R` may not be intuitive and it is always better to err on the side of caution. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of R decision\nx <- 3\n1:x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n1:x+2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5\n```\n\n\n:::\n:::\n\n\n\nYou might expect the last command to produce a sequence from $1$ to $x+2$, but in `R` the sequence operator `:` has higher priority than any of the arithmetic operators. So `R` interprets the last command above as `(1:x)+2`, and if we want it differently we need to specify it in an explicit way.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of vector arithmetic\n1:(x+2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n## Types of vector\n\nAll vectors so far have been numeric, but `R` also accepts vectors of characters, logical values and of factors. For example, patients in a clinical trial may be given one of three different doses (low, medium, high) of a drug, which may be considered a factor variable, whose categories or levels are usually adopted to define different groups of observations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a character/logical/factor variables\nmywords <- c(\"This\",\"is\",\"a\",\"character\")\nmywords\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"This\"      \"is\"        \"a\"         \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmytrue <- { mywords == \"is\" }\nmytrue\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nmyfactor <- factor(c(\"Low\",\"Medium\",\"High\",\"Low\",\"Low\"))\nmyfactor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Low    Medium High   Low    Low   \nLevels: High Low Medium\n```\n\n\n:::\n:::\n\n\n\n## Indexing vector components\n\nOften we want to refer to a single or some subset of elements of a vector. To index components of a vector `x`, we use the form `x[...]`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of vector indexing\nx <- c(1,4,7,9)\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 7 9\n```\n\n\n:::\n\n```{.r .cell-code}\nx[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 7 9\n```\n\n\n:::\n\n```{.r .cell-code}\nx[x>4.7]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7 9\n```\n\n\n:::\n:::\n\n\n\n## Arrays and matrices\n\nAn array is a collection of data entries indexed via one or more subscripts. The arguments for defining an array are: 1) a vector of data; 2) a dimension vector giving the number of elements in each dimension. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of an array\nx <- array(c(1,2,3,4),dim=c(4))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nis.array(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- array(x,dim=c(2,2))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- array(seq(1,27,1),dim = c(3,3,3))\nx[1,1,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nx[2,1,1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\nA matrix is a special type of array with two subscripts, and may also be defined using the `matrix` command, and has its own special arithmetic operators and functions: `*` denotes componentwise mulltiplication; `%*%` denotes matrix multiplication; `t` transposes a matrix; `solve` computes its inverse; `eigen` computes the eigenvalues.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a matrix\nx <- matrix(c(1,2,3,4),nrow = 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n\n\n:::\n\n```{.r .cell-code}\neigen(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\neigen() decomposition\n$values\n[1]  5.3722813 -0.3722813\n\n$vectors\n           [,1]       [,2]\n[1,] -0.5657675 -0.9093767\n[2,] -0.8245648  0.4159736\n```\n\n\n:::\n\n```{.r .cell-code}\nt(x) %*% x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5   11\n[2,]   11   25\n```\n\n\n:::\n:::\n\n\n\nAs with vectors, we may use `[...]` to access subsets of arrays and matrices. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a matrix\nx <- matrix(1:9,nrow = 3, byrow = TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n```\n\n\n:::\n\n```{.r .cell-code}\nx[c(1,3),-3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    7    8\n```\n\n\n:::\n:::\n\n\n\n# Lists and Data Frames\n\n## Lists\n\nLists are useful for collecting a variety of related data types under one object, with individual items that can be recalled by using the `$` sign. The command below is split over two lines, with `R` recognising the first command to be incomplete and responding with a `+` prompt rather than the usual `>` to indicate that it expects the command to be continued.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a list\nexlist <- list(names=\"David\", profession=\"Data scientist\",\n               no.children=3,child.ages=c(3,5,7))\nexlist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"David\"\n\n$profession\n[1] \"Data scientist\"\n\n$no.children\n[1] 3\n\n$child.ages\n[1] 3 5 7\n```\n\n\n:::\n:::\n\n\n\nNote that some `R` functions return a list of results; for example, `eigen()` returns the eigenvectors and eigenvalues separately in a list.\n\n## Data frames\n\nVectors can be put together to make flexible data structures called data frames, which is a collection of column vectors each of the same length. Each column and row of a data frame is given a name which can be chosen by the user or assigned a default by `R`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a data frame\nmonsters <- c(\"Devil\",\"Goblin\",\"Zombie\",\"Orc\")\ncolor <- factor(c(\"red\",\"green\",\"black\",\"green\"))\nn <- c(1,20,NA,2)\ndatafr <- data.frame(monsters,color,n)\ndatafr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  monsters color  n\n1    Devil   red  1\n2   Goblin green 20\n3   Zombie black NA\n4      Orc green  2\n```\n\n\n:::\n:::\n\n\n\nData frames allow data to be accessed in a flexible way. In general, data frames must be attached, with the command `attach()`, before the variables (columns) can be accessed by name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a data frame\ndatafr$n\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 20 NA  2\n```\n\n\n:::\n\n```{.r .cell-code}\nmonsters[color==\"red\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Devil\"\n```\n\n\n:::\n:::\n\n\n\nNote that, since not all values in the column `n` are known, `R` is unable by default to compute summary statistics for this vector. However, we can force `R` to compute these after deleting all unknown values denoted as `NA`s.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example of a data frame\nmean(datafr$n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(datafr$n, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.666667\n```\n\n\n:::\n:::\n\n\n\n# Use of files\n\n## Current working directory\n\nWhen you ask `R` to access information from a file, by default, it assumes that the file is located in the current working directory. The same applies when you ask `R` to save something. To find out what this is, use the `getwd()` command  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check current wd\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"C:/Users/andre/Documents/git/angabrio.github.io/angabrio.github.io/teaching/2025-05-01-intro-R\"\n```\n\n\n:::\n:::\n\n\n\nNotice that `R` uses a forward slash `/` as a directory separator, whereas Windows usually adopts a backslash `\\`. When using `R` under Windows you should usually change the current working directory as otherwise you are likely to forget where your files are. The easiest way to change wd is via the `Change dir` command on the `File` menu, which allows you to browse the directory structure on the machine and select the directory you want. Alternatively, you can set the wd by using the `setwd()` command.  \n\n## Reading data from files\n\nTo input data from external files use the functions `read.table()`, `read.fwf()` or `scan()`. Note that the external files must be in ASCII format so that if created in Word they need to be saved as an ASCII or \"text\" file. An example of an ASCII file is Wordpad, which you can use to create a text file in your current wd and name it `somedata.txt` containing the following.\n\n```\n2 100\n3 44.5\n```\nwhich you can then read in `R` as\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read txt file\nx <- read.table(\"somedata.txt\", header = FALSE)\n```\n:::\n\n\n\n## Reading commands from a file\n\nUsually, when carrying out analyses, it is helpful to store all of your commands in a script, which is just another ASCII file, so to repeat and modify the analysis later on. `R` has its own inbuilt editor for creating scripts, which can be accessed by selecting the `New Script` option on the `File` menu. To reopen a script that was previously saved, use the `Open script` option.  \n\nTry to select the `New Script` option on the `File` menu, which will open an empty window headed `Untitled - R Editor` and type the following lines into this window.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# script\ndat <- c(3,3,3)\nprint(dat)\n```\n:::\n\n\n\nNow go back to the `File` menu, select `Save`, check that the `Save as type` field says `R files`, and save the file with the name `somecommands.R`. To execute the commands in an `R` script, use the `source()` command at the prompt.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# source code file\nsource(\"somecommands.R\")\n```\n:::\n\n\n\nYou can also paste and copy commands from the script window to the prompt window by pressing `<Ctr - R>`.\n\n## Commenting your progress {#sec-commprog}\n\nTo make your code readable, it is helpful to insert lines, or comments, to explain what each part of code is doing. To include comments in `R` use the character `#`, which will make `R` ignore everything on a line after encountering this character.    \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# comments\n# This is simple program that shows the value of comments.\n# Starts by asking the user to input their name ...\n#\nusername <- readline(prompt = \"Please input your name: \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPlease input your name: \n```\n\n\n:::\n\n```{.r .cell-code}\n#\n# and then continues by saying hello to them\n#\ncat(paste(\"Hello\", username, \"!\\n\", sep = \"\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello!\n```\n\n\n:::\n:::\n\n\n\nNotice the use of spacing in the example above, where the empty comment lines help you to distinguish the comments from the `R` commands. Clearly commenting your code is very helpful for you and others!\n\n## Saving output to a file\n\nWhen you type commands in `R`, results are written to the screen by default, while the `sink()` command can be used to direct the output to a file instead. This file can then be printed and examined. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save output to a file\nsink(\"somecommands.res\")\nsource(\"somecommands.R\")\nsink()\n```\n:::\n\n\n\nThis way you will not see anything on the screen when you run `source(\"seomcommands.R\")`, and the results are written straight to the ASCII file `somecommands.res` in your current wd. The final `sink()` command tells `R` to stop writing to the file and return the output to the screen once more.\n\n# Writing functions in `R`\n\nControl structures are the commands which make decisions or execute loops, and are fundamental building blocks when writing `R` programs. We consider:\n\n  - Conditional execution of statements;\n  \n  - Loops.\n\n## Conditional execution of statements\n\nConditional execution can be done by using the `if` statement, with the general structure being\n\n```\nif (condition) statement1 else statement2\n```\n\nFirst, `R` evaluates the `condition`. If the result is `TRUE` or non-zero, the value of the `if` statement is that of `statement1`, otherwise that of `statement2` (if `statement2` is omitted, `R` uses the default `NULL`). The `if` statement can be extended over several lines, and any of the statements may be compounds of simple statements, separated by semi-colons and enclosed within braces `{ }`.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# conditional exe of statements\nx <- 2\ny <- 1\nif (x >= y)\n  { abval <- x - y ;\n  cat(\"\\n\", \"Absolute value is \",\n  abval, \"\\n\")} else\n  { abval <- y - x ;\n  cat(\"\\n\", \"Absolute value is \", abval, \"\\n\")}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Absolute value is  1 \n```\n\n\n:::\n:::\n\n\n\nTo note:\n\n  - The `R` command `cat()` prints out its arguments.\n  \n  - The term `\"\\n\"` causes `R` to insert a carriage return. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# conditional exe of statements\nx <- c(1,3,-2)\nif (is.numeric(x) && min(x) > 0 )\n  sx <- sqrt(x) else\n  stop(\"x must be numeric and positive\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: x must be numeric and positive\n```\n\n\n:::\n:::\n\n\n\nNote:\n\n  - The command `is.numeric()` takes value `TRUE` if `x` has only numeric elements and `FALSE` otherwise. \n  \n  - The logical operator `&&` is simply the standard \"AND\" for logical expressions.\n  \n  - The command `stop()` halts the execution of `R` and prints out any message supplied as an argument.\n\n## Loops\n\nA `for` loop allows a statement to be iterated as a counting variable proceeds through a specified sequence, and has general form\n\n```\nfor (variable in sequence) statements\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# for loop\nfor (i in 1:5 ) cat(3*i, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3 \n6 \n9 \n12 \n15 \n```\n\n\n:::\n:::\n\n\n\nA `while` statement does not make use of a counting variable, and has general form\n\n```\nwhile statements\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# while loop\nx <- 1\nwhile (x < 11 ) {cat(3*x, \"\\n\") ; x <- x + 2}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3 \n9 \n15 \n21 \n27 \n```\n\n\n:::\n:::\n\n\n\nA `repeat` loop executes repeatedly until halted, by `<Ctr-C>` or `Esc`, for example, and has general form\n\n```\nrepeat statements\n```\n\n## Use of control structures\n\nThe `S` language at the basis of `R` is object-oriented, which means that it is designed to work most efficiently by using implicit attributes of the different objects supported. For example, suppose you want to calculate the sum $\\sum_{r=1}^{20} r^4$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# control structure\ntotal <- 0\nfor (r in 1:20) { total <- total + (r^4) }\ntotal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 722666\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# object-oriented structure\nr <- 1:20\ntotal <- sum(r^4)\ntotal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 722666\n```\n\n\n:::\n:::\n\n\n\nThe latter way is the most efficient one in `R`.\n\n## Writing functions\n\nYou can define your own functions in `R` using the `function()` command, which has the general syntax\n\n```\nfname <- function(arg1, arg2, ...) statement\n```\nwhere `arg1`, `arg2`, ... are arguments to be supplied when the function is used. Calling the function is done by\n\n```\nfname(val1, val2, ...)\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# custom function\nssq <- function(x) {\n  ssq <- sum(x*x)\n  scu <- sum(x*x*x)\n  list(sumsq=ssq,sumscu=scu)}\n\nssq(c(1,3,-2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$sumsq\n[1] 14\n\n$sumscu\n[1] 20\n```\n\n\n:::\n:::\n\n\n\nTo note:\n\n  - The arguments of the function can be any `R` object.\n  \n  - The variables within the function are \"local\" - do not appear with `ls()` after function evaluation.\n  \n  - An object `list()` is a collection of possibly different types of object.\n  \n  - The value of a function is the result of the last statement in its definition.\n\nOur function `ssq()` will not work correctly if not supplied with a numeric vector argument, and we could get it to recognise the wrong kind of input as follows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# custom function\nssq <- function(x) {\n  if(!is.numeric(x)) stop(\"You cannot supply a non-numeric input\")\n  ssq <- sum(x*x)\n  scu <- sum(x*x*x)\n  list(sumsq=ssq,sumscu=scu)}\n\nssq(\"Word\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in ssq(\"Word\"): You cannot supply a non-numeric input\n```\n\n\n:::\n:::\n\n\n\n## Supplying default values\n\nSometimes we wish a particular argument of a function to take a default value unless otherwise instructed. This can be achieved with the following general form\n\n```\nfname <- function(arg1=def1, ...) statement\n```\nwhere the value of `arg1` will be `def1` if the user does not supply an alternative. For example, consider the following function calculating the sum of the pth power of the elements of the vector `x`, with the default value of `p` being 2. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# custom function\nsumpow <- function(x, p=2) {\n  sump <- sum(x^p)\n  cat(\"\\n\", \"Sum of elements to power\", \n      p, \"is\",sump,\"\\n\") }\n\nsumpow(x=c(1,-1,2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Sum of elements to power 2 is 6 \n```\n\n\n:::\n\n```{.r .cell-code}\nsumpow(x=c(3,3), p=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Sum of elements to power 5 is 486 \n```\n\n\n:::\n:::\n\n\n\n# Graphics\n\nMany `R` commands produce high-quality graphical output, which can be saved to a variety of file format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#plot graphics\nx <- seq(-5,5,0.1)\ny <- x^2\nplot(x,y,type = \"l\")\n```\n\n::: {.cell-output-display}\n![Line graph.](index_files/figure-html/fig-1-1.png){#fig-1 fig-pos='h' width=70%}\n:::\n:::\n\n\n\nFile formats `\"jpeg\"` and `\"png\"` may be used to produce graphics that can be imported into Word documents, while `\"pdf\"` and `\"postscript\"` formats into latex documents.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# save graphics as files\ndev.copy(jpeg,\"quadratic.jpg\", quality=95)\ndev.off()\ndev.copy(pdf,\"quadratic.pdf\", width=8, height=6)\ndev.off()\n```\n:::\n\n\n\n## The help system\n\n`R` comes with a built-in help system, which may be accessed using the `help()` function, i.e. `help(plot)`. To search for a specific topic use `help.search()`. Some of these help outputs can be quite long and you may therefore like to know about the `example()` command, which makes `R` work through the examples in the help file. For example, consider the `persp()` command.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# help\nhelp(persp)\nexample(persp)\n```\n:::\n\n\n\n# References\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}