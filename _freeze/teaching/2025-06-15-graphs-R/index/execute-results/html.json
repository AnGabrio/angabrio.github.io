{
  "hash": "71de1551959c15ff0493e513d324fc27",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Graphics in R\"\ndescription: \"\"\nauthor:\n  - name: Andrea Gabrio\n    url: https://angabrio.github.io/agabriosite2/\n    orcid: 0000-0002-7650-4534\n    email: a.gabrio@maastrichtuniversity.nl\n    corresponding: true    \n    affiliation: Maastricht University\n    affiliation-url: https://www.maastrichtuniversity.nl/research/methodology-and-statistics\ndate: 2025-06-15\ncategories: [Quarto, R, Teaching, Software, Statistics, RMT1005, Graphs] # self-defined categories\nimage: featured.png\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\nkeywords:\n  - Software\n  - Statistics\n  - R\n  - Teaching\n  - RMT1005\n  - Graphs\nbibliography: ref.bib\nnocite: |\n  @rsoftware, @wickham2017r, @field2012discovering, @kabacoff2022r, @crawley2012r\n---\n\n\n\n# Introduction and Preliminaries\n\nThe ability to represent data graphically is an important part of data analysis because:\n\n  - At the start of an analysis, investigating the data visually helps you to get to know the data that you will be working with: identify data errors or outliers; suggest structures that may be present in the data.\n  \n  - As part of the analysis, graphs can be used to check assumptions and to interpret results.\n  \n  - If constructed carefully, graphics often provide powerful means of communicating information to other people in informal discussions, presentations or written reports.\n\n`R` has a wide range of plotting capabilities and the graphics can be customised extensively. We will cover the basics, including enhancing plots by adding additional graphics and text, and using parameters to customise your graphics. You should work through the examples and exercises given in these note, and you are encouraged to try out variations to the given commands to see how these affect the results. You may also read more about the functions in the help pages by typing `help(name.of.function)` or `help.start()` to browse the available functions. \nStart `R` and then use `setwd()` or `File --> Change dir` to change the working directory for your `R` work. It is helpful to type your commands into a script window and run them using `Ctrl-R`. At the end of the sessions, you may save your commands for future reference. Open a new script window (`File --> New script`) and be ready to start.\n\n# High level plots\n\n## The `plot()` function\n\nIn `R`, there is a function `plot()` which, in its simple form, accepts as arguments the $x$- and $y$- axis, and opens a graphics device showing a scatter plot. For instance, define two vectors called `xvalues` and `quadx` and then produce a scatter plot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxvalues <- -5:5\nquadx <- xvalues^2\nplot(xvalues,quadx, type=\"p\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\nThe argument `type=\"p\"` specifies that \"points\" should be plotted (the default). The other values that the `type` argument can take are: `\"l\"` for lines, `\"b\"` for points and lines, `\"s\"` for stepped, `\"h\"` for hi-density (vertical lines from the x-axis to the points), and `\"n\"` for none (only plot the axes).\n\n### Exercises\n\n  1. Repeat the plot command with different settings for `type`. \n  \n  2. The object `quadx` is used as an example. Try plotting different functions such as `exp(xvalues)`, `abs(xvalues)`, and `sin(xvalues)`.\n  \n  3. Try to plot `log(xvalues)` against `xvalues`, what happens? Change the vector `xvalues` to get a sensible plot.\n\nNotice that every time you enter a plot command, the graphics window is cleared and a new graphic is drawn, as opposed to adding to or changing the existing plot. This is because `plot` is a high-level graphics command, as opposed to a low-level command which is used to add things to an existing graph. We will explore some other high-level commands.\n\n## Bar charts\n\nBar charts can be obtained for univariate or multivariate data, with the argument supplied being a vector of the heights or the frequencies for each bar. Load in the data `VADeaths`, quickly read the help file, and plot some bar charts.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(VADeaths)\nhelp(VADeaths)\nVADeaths[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Rural Male Rural Female   Urban Male Urban Female \n        11.7          8.7         15.4          8.4 \n```\n\n\n:::\n\n```{.r .cell-code}\nbarplot(VADeaths[1,])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nVADeaths\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Rural Male Rural Female Urban Male Urban Female\n50-54       11.7          8.7       15.4          8.4\n55-59       18.1         11.7       24.3         13.6\n60-64       26.9         20.3       37.0         19.3\n65-69       41.0         30.9       54.6         35.1\n70-74       66.0         54.3       71.1         50.0\n```\n\n\n:::\n\n```{.r .cell-code}\nbarplot(VADeaths)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n\n```{.r .cell-code}\nbarplot(VADeaths,beside = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-3.png){width=672}\n:::\n\n```{.r .cell-code}\nt(VADeaths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             50-54 55-59 60-64 65-69 70-74\nRural Male    11.7  18.1  26.9  41.0  66.0\nRural Female   8.7  11.7  20.3  30.9  54.3\nUrban Male    15.4  24.3  37.0  54.6  71.1\nUrban Female   8.4  13.6  19.3  35.1  50.0\n```\n\n\n:::\n\n```{.r .cell-code}\nbarplot(t(VADeaths))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-4.png){width=672}\n:::\n:::\n\n\n\nThe function `t()` transposes a matrix.\n\n## Histograms and density estimation\n\nHistograms are used to show frequency distributions of continuous variables. The `R` command `hist` accepts as its first argument a numeric vector containing the individual observations. The function `rnorm()` generates a sample of random numbers from a standard normal distribution. To obtain ten of such numbers type\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1.08716744 -0.19157200 -0.23018842 -1.36496537 -1.88309166 -0.05321759\n [7]  0.28178920 -0.02726717  0.67255752  0.44063260\n```\n\n\n:::\n:::\n\n\n\nType in the same thing again, you will notice that the numbers are different each time. Now use this function to plot a histogram of $1000$ standard normal observations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(rnorm(1000))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\nNotice that here the `rnorm()` command is nested within the `hist` command. By doing so, `R` will work from the inside out by evaluating first the inner expression `rnorm(1000)`, then passing the result as an argument to the `hist` command. Multiple layers of nesting can be used, which may be helpful to save you from storing lots of objects that are not needed. However, excessive nesting can make your code difficult to read, so use your judgement! You can specify a different mean and standard deviation to `rnorm` using the arguments `mean=` and `sd=`; play about with these arguments and see how the histograms change. Now try\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(rexp(1000,4))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nWhat do you think the histogram shows? Experiment with the arguments `breaks=n`, where `n` is a number of your choice, and `prob=TRUE`, observing how the resulting histograms differ. \n\nA more sophisticated version of a histogram is a kernel density estimate, which can be thought as a smoothed histogram. The `density` command calculates a kernel density estimate, which is recognised by the `plot` command, and produces the appropriate type of plot automatically.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- rnorm(50)\nplot(density(y))\nrug(y)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nWhat did the last command do? \n\n## Boxplots\n\nA boxplot is used to compare a numeric variable across several groups. The exact format of a boxplot differs between packages. In `R`, the box is defined by the lower quartile, median and upper quartile, while the whiskers extend to the data point that is no more then $1.5$ times the interquartile range from the box. Any observation outside the whiskers is defined as an extreme value and is plotted individually.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(OrchardSprays)\nhelp(OrchardSprays)\nboxplot(decrease ~ treatment, data = OrchardSprays)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\nboxplot(decrease ~ treatment, data = OrchardSprays, horizontal = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n\n```{.r .cell-code}\nboxplot(decrease ~ treatment, data = OrchardSprays,\n        log=\"y\", col=\"bisque\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-3.png){width=672}\n:::\n:::\n\n\n\nNotice the notation: `decrease ~ treatment`, which is an `R` model formula, and is read as `decrease` depends on `treatment` using the data `OrchardSprays`.\n\n## Quantile plots\n\nA quantile plot allows the visual assessment of how well a continuous variable fits a known distribution. A bivariate Q-Q plot compares the distribution of two sets of data:\n\n  - `qqnorm(x)` plots the ordered values of `x` against quantiles of a normal distribution, using the sample mean and variance of `x`.\n  \n  - `qqplot(x)` plots the ordered values of `y` against the ordered values of `x`, where `x` may contain the quantiles of a known distribution, or another data set. \n\nIn both cases the ideal plot will be a diagonal straight line.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqqnorm(OrchardSprays$decrease)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\nqqnorm(log(OrchardSprays$decrease))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n:::\n\n\n\nLet's now see whether an exponential distribution can be used to model these data. We may estimate the parameter of said distribution by typing\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlambda <- 1 / mean(OrchardSprays$decrease)\nlambda\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.02201582\n```\n\n\n:::\n:::\n\n\n\nFrom the data, we can estimate $n$ quantiles simply putting the observations into ascending order. To compare with the exponential distribution we need to find the appropriate quantiles of that distribution. If $X \\sim \\text{Exp}(\\lambda)$, then the $p_i$-th quantile satisfies:\n\n$$\nP(X \\leq q_i) = p_i, \\;\\;\\; i=1,\\ldots, n.\n$$\n\nThe question is now what values of $p_i$ are required? We are going to compare with the quantiles from the data, so it seems reasonable to take values of $p_i$ that are equally spaced between $0$ and $1$. The function `ppoints(n)` returns a vector with appropriate probability points such that $p_i=(i-\\frac{1}{2})/(n+\\frac{1}{2}))$. Notice the offset of $1/2$ in both the numerator and denominator. This is required because without it $p_n=1$. The value of $1/2$ can be changed if desired. The quantiles of the exponential distribution can be obtained using `qexp()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- length(OrchardSprays$decrease)\nprob.grid <- ppoints(n)\nqqplot(qexp(prob.grid,rate=lambda), OrchardSprays$decrease)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n## Plotting multivariate data\n\nThe `matplot()` function plots each column of a matrix or data frame as a different series.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(USArrests)\nhelp(USArrests)\nmatplot(USArrests, type = \"l\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n## Pairwise plots\n\nThe `pairs` command plots each pairwise combination of variables in a data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npairs(USArrests)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\nYou could argue that the diagonal space on the plot is wasted. In fact the `pairs` command allows you to define other plots to go down the diagonal. One nice thing about `R` is that there are many add-on packages that you may download and install. The `car` library is one of these and contains a very easy-to-use alternative to the `pairs` command.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(car)\nscatterplotMatrix(USArrests, diagonal = \"density\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nThe first command makes the `car` package available to your current `R` session (after installing the package with `install.packages()`). \n\n## Conditioning plots\n\nA conditioning plot creates several \"panels\" of scatter plots, where the panel in which each point is plotted depends on a third variable, which may be a factor variable or a partition of a continuous variable. The next example uses the `Iris` data, containing measurements from iris flours of different species. Once obtained the first plot, look at how many clusters of data appear, then produce the conditioning plot. How many clusters are there now?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\nnames(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(iris$Sepal.Length,iris$Petal.Length)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncoplot(Sepal.Length ~ Sepal.Length | Species, data = iris)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\n\nNotice again the formula notation, where `Sepal.Length` depends on `Sepal.Length` given `Species`. An example of conditioning on a continous variable is\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(swiss)\nnames(swiss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fertility\"        \"Agriculture\"      \"Examination\"      \"Education\"       \n[5] \"Catholic\"         \"Infant.Mortality\"\n```\n\n\n:::\n\n```{.r .cell-code}\ncoplot(Fertility ~ Education | Agriculture, data=swiss, overlap = 0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncoplot(Fertility ~ Education | Agriculture, data=swiss, overlap = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n\n```{.r .cell-code}\ncoplot(Fertility ~ Education | Agriculture, data=swiss, overlap = 0.5,\n       panel = panel.smooth)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-3.png){width=672}\n:::\n:::\n\n\n\nThe panels are ordered bottom left, bottom middle, bottom right, ..., top right. What do you think the arguments `overlap` and `panel` do? Conditioning plots can be useful at the initial stages of a data analysis, once you work out and interpret them. Many different types of conditioning plots are available in `R` in the library called lattice, which you may load by typing `require(lattice)` or `library(lattice)` at the `R` prompt.\n\n## The `plot()` function for different classes\n\nThere are actually different versions of `plot()`. When it is called, the first thing it does is look at the calls of its first argument, and then produce a graphic that is suited to the situation. For example, if `x` is a data frame, then a function named `plot.data.frame()` is called and a pairs plot is produced. When plotting a kernel density estimate, the object `density(y)` has class `\"density\"` and the `plot.density()` function is called to produce a line graph. If a class of an object does not match any `R` function of the form `plot.something()`, then `plot.default()` is used, which is a scatter plot.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(OrchardSprays)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(OrchardSprays)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndata(state)\nclass(state.division)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(state.division)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n:::\n\n\n\n# Enhancing an adapting graphs\n\nOften we wish to customise a plot in some way. There are generally three ways to do this.\n\n  - By using `arguments` supplied to the high-level plotting function.\n  \n  - By using other functions after the high-level plot has been created.\n\n  - By changing the default settings using the function `par()`.\n\n## Arguments\n\nArguments that can be specified in most high-level plot functions include: `main` (titel); `sub` (subtitle); `xlab` (x-axis label); `ylab` (y-axis label); `xlim` (min and max of x-axis); `ylim` (min and max of y-axis); `col` (clor); `col.axis` (color for axis); `col.lab` (color for label); `col.main` (color for title); `col.sub` (color for subtitle); `lty` (line type); `lwd` (line width); `pch` (plotting symbol); `log` (plot using log scale); `cex` (text size); `axes` (keep or not the axes).\n\nFor example,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxvalues <- -5:5\nquadx <- xvalues^2\nplot(xvalues, quadx, type = \"b\", main = \"Title\",\n     sub = \"subtitle\", xlab = \"x\", ylab = \"x squared\",\n     col.main = \"green\", col = \"blue\", lty = 2, pch = \"*\",\n     lwd = 3, cex = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(xvalues, quadx, xlim=c(-10,10))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-2.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(xvalues, quadx, xlim=c(-10,10),axes=FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-3.png){width=672}\n:::\n:::\n\n\n\nThere are also some arguments that can only be used with a specific type of high-level plot, such as `beside` for `barplot`, `breaks` for `hist` and `notch` for `boxplot`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(decrease ~ treatment, data = OrchardSprays,\n        log = \"y\", col = \"lightblue\", notch = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\nThe value of `pch` can be a character, usually `\"o\"`, `\"+\"`, `\"*\"`, or `\".\"`, or it can be a number. When data values are discrete, scatter plots can be difficult to interpret. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(morley)\nplot(morley$Expt,morley$Speed)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nHow many observations can you see in \"Experiment 5\"? Now try the following:\n\n  - Use the function `jitter()` to add a small amount of noise to one of the variables.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(jitter(morley$Expt),morley$Speed)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n  - Use the `sunflowerplot()` function to add petals to multiple observations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsunflowerplot(morley$Expt,morley$Speed)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n  - Use numbers rather than potting symbols on the scatter plot. There is no nice command for this, and the easiest way is to make an invisible `sunflowerplot` and store the data represented there.\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmorley.agg <- sunflowerplot(morley$Expt,morley$Speed,col=0,seg.col=0)\ntext(x=morley.agg$x,y=morley.agg$y,labels=morley.agg$number)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\nHow many observations are there in \"Experiment 5\"?\n\n## Adding to existing plots\n\nSome functions that add to an existing plot are: `points` (points); `lines` (lines); `matpoints` (mat points); `matlines` (mat lines); `title` (title); `axis` (axes); `abline` (straight line); `text` (text); `legend` (legend); `qqline` (Q-Q plot). \n\nThe `mtcars` dataset conatins data on different North American cars.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(mtcars)\n```\n:::\n\n\n\nNow usw the `data()` command to read in the dataset. We can plot the fuel economy against the weight of the car.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mtcars)\nplot(mtcars$wt,mtcars$mpg)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\nWe can also show how the number of cylinders in the same engine relates to the fuel economy and weight of a car. First define logical vectors to identify the cars that have four, six and eight cylinders:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfourcyl <- mtcars$cyl == 4\nsixcyl <- mtcars$cyl == 6\neightcyl <- mtcars$cyl == 8\n```\n:::\n\n\n\nNow plot each subset separately, look at the plot after typing each command to see what the command does.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mtcars$wt,mtcars$mpg, type = \"n\")\npoints(mtcars$wt[fourcyl],mtcars$mpg[fourcyl],pch=\"+\",col=\"blue\")\npoints(mtcars$wt[sixcyl],mtcars$mpg[sixcyl],pch=\"o\",col=\"red\")\npoints(mtcars$wt[eightcyl],mtcars$mpg[eightcyl],pch=\"x\",col=\"magenta\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\nThe argument `type=\"n\"` was chosen to set up the plotting area to match the entire dataset. We then used `points()` to plot each subset separately. The choice of colours available in `R` is extensive, with the full list available by typing `colors()`. Now we can add a line showing the median fuel economy and a legend.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabline(h=median(mtcars[,\"mpg\"]), col=\"green\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet\n```\n\n\n:::\n\n```{.r .cell-code}\nlegend(4,34.0, legend = c(\"Four Cylinder\", \"Six Cylinder\", \"Eight Cylinder\"),\n       col = c(\"blue\",\"red\",\"magenta\"), pch = c(\"+\",\"o\",\"x\"))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in (function (s, units = \"user\", cex = NULL, font = NULL, vfont = NULL, : plot.new has not been called yet\n```\n\n\n:::\n:::\n\n\n\nThe `abline` command takes several arguments: `h` (horizontal line), `v` (vertical line), `a,b` (intercept and slope of straight line), `coef` (vector of length two containing intercept and slope). The first two arguments of `legend` are the $x$ and $y$ coordinates of the top left hand corner of the legend, the argument `legend` is a vector of labels, and `pch` is a vector of plotting symbols. You need to use `lty` instead of `pch` when adding a legend to a line plot. Type\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentify(mtcars$wt,mtcars$mpg,row.names(mtcars))\n```\n:::\n\n\n\nand click on the points. When finished, click the right mouse button to return to the prompt.\n\n### An example using `axis()`\n\nTo place the axes through the origin\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(xvalues,quadx,axes = FALSE)\naxis(side=1,pos=0,at=c(-5,0,5))\naxis(side=2,pos=0,at=c(0,5,10,15,20,25),\n     labels = c(\"\",\"5\",\"10\",\"15\",\"20\",\"25\"), las = 1)\nbox()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\nThe `axes=FALSE` argument removes the axes. In the command `axis`, the argument `side` takes values 1,2,3 or 4 for bottom, left, top and right axis. The `pos=0` argument places the axis at zero, while the last argument `las=1` tells `R` to place the labels horizontally. \n\n### The `par()` function\n\nThe `par()` function allows the user to set many graphics parameters, which will be kept until the session is closed or until they reset the parameters. Popular arguments include: `col`, `col.axis`, `col.lab`, `col.main`, `col.sub`, `lty`, `lwd`, `pch`, `log`, `cex`, `axes` and `las`. Other arguments are `bg` (background colour), `font` (font), and `mfrow` (multiple plots in same window). For example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mtcars$wt,mtcars$mpg)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(xvalues,quadx,type = \"b\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-2.png){width=672}\n:::\n:::\n\n\n\nTo modify the layout of the plot, we can use\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(3,2))\n```\n:::\n\n\n\nwhereas to reset the parameters we type\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,1))\n```\n:::\n\n\n\n## Graphics devices\n\nThe window in which you see the plot is called a graphics device, and was started when you entered the first high-level plot command. You can open up a new device with the command\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx11()\n```\n:::\n\n\n\nNotice that the new device is labelled `ACTIVE` and the old one is called `inactive`. Enter a simple graphics command to see that the plot appears on the new device. `dev.list()` returns a list of all the devices that are open at any time; `dev.set(2)` changes the active device to device two. Enter another plot command to verify this. To close down a device type `dev.off()`. There are other devices such as `\"jpeg\"`, `\"pdf\"`, and `\"postscript\"`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npdf(file=\"graphicstest.pdf\",paper=\"a4\")\n#any plotting commands\n#go here\ndev.off()\n```\n:::\n\n\n\nThis will create a graphics file with the name `\"graphicstest.pdf\"`, which is not completed until it is closed using `dev.off()`. Notice that you cannot see the graphics on the screen but they are sent directly to the graphics file. If you want to see the graphics on the screen before saving them in a `PDF` file use the commands\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#any plotting commands\n#go here\ndev.copy(pdf,\"graphicstest.pdf\",paper=\"a4\")\ndev.off()\n```\n:::\n\n\n\nA problem when using `dev.copy()` is that the size of the output graphics device may be different from the size of the screen window. To handle this, you may explicitly control the size of both the graphics window and the output device. For example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx11(width = 11, height=8)\n#any plotting commands\n#go here\ndev.copy(pdf,\"graphicstest.pdf\",width=11,height=8)\ndev.off()\ndev.copy(jpeg,\"graphicstest.jpeg\",width=800,height=600)\ndev.off()\n```\n:::\n\n\n\nUnder the Windows version of `R` you can use the menus to print and save graphics.\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}