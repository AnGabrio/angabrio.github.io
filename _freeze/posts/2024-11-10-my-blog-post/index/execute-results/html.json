{
  "hash": "a0bc1e2f6375df3fd147b020c73b42ea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Markov Models in Economic Evaluations\"\ndescription: \"\"\nauthor:\n  - name: Andrea Gabrio\n    url: https://angabrio.github.io/agabriosite2/\n    orcid: 0000-0002-7650-4534\n    affiliation: Maastricht University\n    affiliation-url: https://www.maastrichtuniversity.nl/research/methodology-and-statistics\ndate: 2024-11-10\ncategories: [Quarto, R, Academia, Health Economics] # self-defined categories\n#citation: \n#  url: https://samanthacsik.github.io/posts/2022-10-24-my-blog-post/ \nimage: featured.png\nbibliography: references.bib\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\n![](featured.png){fig-align=\"center\"}\n\nHello dear readers and welcome to a new post of my blog. Today, I would like to continue the discussion initiated with the last post about modelling in health economic evaluations, particularly with respect to the construction and implementation of decision analytic models or DAMs, such as the *Decision Tree Models* that were introduced last time. Picking up on this trend, in this post I would like to introduce and talk about *Markov Models* in economic evaluation, mostly drawing inspiration and references from the book @khan2015design (Chapter 6) which contains a nice introduction and overview on this topic. As usual warning for the casual reader: in this post I may use some terms that are specific to the health economics literature and field without diving into too many explanations; when this is the case, please bear with me and perhaps make a quick online search (or check my previous posts) to check if anything is unclear to you. For a look at how to implement more complex types of markov models, I recommend checking this nice [post](https://rpubs.com/mbounthavong/markov_model_using_excel), although it is mostly focussed on the implementation of such models in `Excel`, and `heemod` package [vignette](https://cran.r-project.org/web/packages/heemod/vignettes/c_homogeneous.html) for `R`.\n\n## Markov Models\n\nWhen the complexity of the modelling task for disease progression increases considerably, e.g. because of many possible mutually exclusive outcomes or the need to repeat the analysis at given time intervals, the use and implementation of decision tree (explored in the previous post) may become quite burdensome. Rather than creating very complex branches and estimate the costs and effects associated with each possible outcome within each branch of the decision tree, it is often more useful to specify the modelling task with respect to the transition of the patients through different (and more limited) health states via *Markov Models*. More specifically, a Markov model in economic evaluation aims at modelling the transition of patients from one health state to another, and estimate the costs and effects expected to accrue as a result of transitions between health states over a period of time. The period of time over which these transitions are observed (denoted as cycle) may vary depending on the context and the type of disease being modelled, e.g. a week, a month, a year, or even a lifetime. \n\nIn Markov Models, the probabilities of moving between health states are captured as a matrix of probabilities called a *transition matrix*, where chance of moving to a different health state depends only on the current health state (and not on health states prior to the current state). This is called the **Markov property**: $X_{t+1} = X_t + \\varepsilon$, where $X_{t+1}$ is the health state at time $t+1$ and is dependent only on the current health state $X_t$. An example of a simple  Markov model is shown in the thumbnail figure of this post and formed by three health states (well, sick, dead) and arrows denoting the direction of the possible transitions between states. Since Markov Models are mostly simulation-based methods, no individual-level data are used to fit the models which are instead based on some aggregated data obtained from the literature or expert elicitation. This also includes the choice for the values of the transition probabilities, whose identification and selection should go through a rigorous process to ensure its reliability and appropriateness.\n\n## A simple example \n\nAs a demonstrative example, let's consider the transition matrix shown in @tbl-example, which displays the assumed transition probabilities for three health states (Well, Sick and Dead) from baseline (rows) to 1 month follow-up (columns), for an hypothetical experimental treatment.\n\n\n\n::: {#tbl-example .cell tbl-cap='Example Transition Matrix on Experimental Treatment after 1 Month Post-Randomisation'}\n::: {.cell-output-display}\n\n\n|     | Well| Sick| Dead| Total|\n|:----|----:|----:|----:|-----:|\n|Well | 0.45| 0.35| 0.20|     1|\n|Sick | 0.05| 0.60| 0.35|     1|\n|Dead | 0.00| 0.00| 1.00|     1|\n\n\n:::\n:::\n\n\n\nLet's also assume that patients were randomised to one of two treatments, namely Experimental vs Control, and they were considered to be in either a Well or Sick state. From @tbl-example, we can see that the proportion of patients who started the hypothetical trial at baseline in a Well state and then remained in the same state after treatment was $45\\%$, very few patients ($5\\%$) who started the trial in a Sick state improved into a Well state at follow up, and $60\\%$ of patients who were in the Sick state did not change states after starting treatment. In order to compute what the transition matrix will look like after $1$ month, we need to know the initial probabilities (or the probabilities at baseline), say equal to the first row of @tbl-example. After $1$ month of treatment, the transition matrix is updated by multiplying the initial probabilities by the $3\\times3$ transition matrix in @tbl-example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_update <- matrix(c(0.45,0.05,0,0.35,0.6,0,0.2,0.35,1),3,3) \ntm_init <- c(0.45,0.35,0.2)\ntm_1m <- tm_init%*%tm_update\n\ntm_1m\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]   [,2]   [,3]\n[1,] 0.22 0.3675 0.4125\n```\n\n\n:::\n:::\n\n\n\nThe above $1\\times3$ \"matrix\" denotes the probabilities in each of the three health states of the model at 1 month after treatment and becomes the initial matrix needed for further calculations. After $2$ months (second cycle of the process), the updated transition matrix is obtained by multiplying the above matrix again by the $3 \\times 3$ transition matrix in @tbl-example, and so on. In general, one can compute the proportion of patients for the $n+1$-th step in any of these three health states by simply multiplying the updated transition matrix at step $n$ by the given transition matrix:\n\n$$\nM_n = M_{n-1}\\times P, \n$$\nwhere $M_n$ and $M_{n-1}$ denote the $1\\times 3$ transition matrix at step $n$ and $n-1$, while $P$ denotes the constant $3\\times3$ transition matrix used to update the probabilities at each step. Finally, the last important factor associated with the Markov model is the duration of the interval of time, termed a *cycle*, set to $1$ month in the example above. In general, the length of the cycle could be longer or shorter, with shorter cycles needing more computations since they imply a more frequent update of the transition probabilities, i.e. more steps to run.\n\nTo continue our example, let's now consider a more realistic scenario where the transition matrix and initial probabilities are provided for both an experimental group and a control group form an hypothetical trial assessing the cost-effectiveness of the two treatments. The $3\\times3$ transition matrices associated with the two treatments ($P^{exp},P^{ctr}$) are shown in @tbl-example2, while the $1\\times3$ matrices of the initial probabilities ($M^{exp}_0,M^{ctr}_{0}$) of the two groups are assumed to be equal to the first row of their respective transition matrices. \n\n\n\n::: {#tbl-example2 .cell tbl-cap='Example Transition Matrices on Experimental and Control Treatment after 1 Month Post-Randomisation'}\n::: {.cell-output-display}\n\n\n|     | Well| Sick| Dead| Total|\n|:----|----:|----:|----:|-----:|\n|Well | 0.45| 0.35| 0.20|     1|\n|Sick | 0.05| 0.60| 0.35|     1|\n|Dead | 0.00| 0.00| 1.00|     1|\n\n\n:::\n\n::: {.cell-output-display}\n\n\n|     | Well| Sick| Dead| Total|\n|:----|----:|----:|----:|-----:|\n|Well | 0.25| 0.25| 0.50|     1|\n|Sick | 0.10| 0.45| 0.45|     1|\n|Dead | 0.00| 0.00| 1.00|     1|\n\n\n:::\n:::\n\n\n\nWe can therefore update the transition matrices of the two treatments over $5$ cycles, each of $1$ months, by doing the following\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#experimental treatment\ntm_exp_update <- matrix(c(0.45,0.05,0,0.35,0.6,0,0.2,0.35,1),3,3) \ntm_exp_init <- c(0.45,0.35,0.2)\n#update over 5 cycles\ntm_exp_1m <- tm_exp_init%*%tm_exp_update\ntm_exp_2m <- tm_exp_1m%*%tm_exp_update\ntm_exp_3m <- tm_exp_2m%*%tm_exp_update\ntm_exp_4m <- tm_exp_3m%*%tm_exp_update\ntm_exp_5m <- tm_exp_4m%*%tm_exp_update\n\n#control treatment\ntm_ctr_update <- matrix(c(0.25,0.10,0,0.25,0.45,0,0.50,0.45,1),3,3) \ntm_ctr_init <- c(0.25,0.25,0.50)\n#update over 5 cycles\ntm_ctr_1m <- tm_ctr_init%*%tm_ctr_update\ntm_ctr_2m <- tm_ctr_1m%*%tm_ctr_update\ntm_ctr_3m <- tm_ctr_2m%*%tm_ctr_update\ntm_ctr_4m <- tm_ctr_3m%*%tm_ctr_update\ntm_ctr_5m <- tm_ctr_4m%*%tm_ctr_update\n\n#experimental TM at the end of 5th cycle\ntm_exp_5m\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]      [,2]    [,3]\n[1,] 0.02642064 0.1077694 0.86581\n```\n\n\n:::\n\n```{.r .cell-code}\n#control TM at the end of 5th cycle\ntm_ctr_5m\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            [,1]       [,2]      [,3]\n[1,] 0.005600547 0.01602453 0.9783749\n```\n\n\n:::\n:::\n\n\n\nOnce the transition probabilities over the desired number of cycles are estimated, further data manipulation can be carried out to estimate the expected costs and effects, which can be included in an additional vector and then multiplied with the elements of the matrices after each cycle to generate the expected total costs and effects. As an example, let's assume that patients were treated for $3$ months but followed up for $12$ months during the trial and that costs were collected from patients files and measured in euros, while effects were collected via self-reported questionnaires (e.g. EQ-5D) and measured via utilities. We need to associate to each health state and treatment in the model a corresponding value for each of the outcomes that we want to measure, i.e. costs and utilities. Thus, we may assume that (monthly) utilities for each health state are $u^{well}=0.78$, $u^{sick}=0.40$, and $u^{dead}=0$, but are constant across treatments. Conversely, we may assume that (monthly) costs are constant across health states but vary between treatment groups, i.e. $c_{exp}=954$ and $c^{ctr}=435$. Next, we need to determine the number of cycles of the model. In this case, we will use $12$ cycles given that we focus over a $1$ year follow-up, with each cycle being $1$ month long. Hence, the expected costs and QALYs for each month will be generated and then added up. \n\nThe proportion of patients in each of the health states at the start of the model needs to be determined, typically an arbitrary large number, e.g. $10000$, since the idea is to estimate the cumulative costs and effects over the $10000$ patients for each group. We can now proceed to calculate the transition matrices and total costs and QALYs associated with both treatment groups over $12$ months via our Markov Model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#set up initial values for the model\n\n#initial transition probs by arm\ntm_exp_init <- c(0.45,0.35,0.2)\ntm_ctr_init <- c(0.25,0.25,0.50)\n#transition matrices by arm\ntm_exp_update <- matrix(c(0.45,0.05,0,0.35,0.6,0,0.2,0.35,1),3,3) \ntm_ctr_update <- matrix(c(0.25,0.10,0,0.25,0.45,0,0.50,0.45,1),3,3) \n#utilities by health state\nu_well <- 0.78\nu_sick <- 0.4\nu_dead <- 0\n#costs by arm\nc_exp <- 954\nc_ctr <- 435\n#number of cycles\nn_cycle <- 12\n#initial number of patients in the cohort\nn_pat <- 10000\n\n  #end of cycle 1 TP\n  trans_mat_cycle1_exp <- tm_exp_init%*%tm_exp_update\n  trans_mat_cycle1_ctr <- tm_ctr_init%*%tm_ctr_update\n  #lists to store TP results by cycle\n  trans_mat_cycles_exp <- list()\n  trans_mat_cycles_ctr <- list()\n  \n\n#create function to run the model\nmm_sim <- function(tm_exp_init,tm_ctr_init,tm_exp_update,tm_ctr_update,\n                   u_well,u_sick,u_dead,c_exp,c_ctr,n_cycle,n_pat){\n  \n  res_list <- res_list_exp <- res_list_ctr <- list()\n  #set up matrices to contain results from all TP over each cycle by group\n  tm_exp <- matrix(NA, nrow = n_cycle+1, ncol = 3)\n  colnames(tm_exp) <- c(\"Well\",\"Sick\",\"Dead\")\n  tm_ctr <- matrix(NA, nrow = n_cycle+1, ncol = 3)\n  colnames(tm_ctr) <- c(\"Well\",\"Sick\",\"Dead\")\n  #assign first row to be initial TP\n  tm_exp[1,] <- tm_exp_init\n  tm_ctr[1,] <- tm_ctr_init\n  #loop through cycles and update TM at each cycle\n  for(i in 2:c(n_cycle+1)){\n    tm_exp[i,] <- tm_exp[i-1,]%*%tm_exp_update\n    tm_ctr[i,] <- tm_ctr[i-1,]%*%tm_ctr_update\n  }\n  #remove intial TP from matrices\n  tm_exp <- tm_exp[-1,]\n  tm_ctr <- tm_ctr[-1,]\n  #using obtained TM to compute number of patients in each health state at each cycle\n  npat_cycle_exp <- matrix(NA, nrow = n_cycle+1, ncol = 3)\n  colnames(npat_cycle_exp) <- c(\"Well\",\"Sick\",\"Dead\")\n  npat_cycle_ctr <- matrix(NA, nrow = n_cycle+1, ncol = 3)\n  colnames(npat_cycle_ctr) <- c(\"Well\",\"Sick\",\"Dead\")\n  npat_cycle_exp <- tm_exp*n_pat\n  npat_cycle_ctr <- tm_ctr*n_pat\n  #and number still alive\n  nailive_cycle_exp <- as.matrix(rowSums(npat_cycle_exp[,-3]))\n  colnames(nailive_cycle_exp) <- \"nalive\"\n  nailive_cycle_ctr <- as.matrix(rowSums(npat_cycle_ctr[,-3]))\n  colnames(nailive_cycle_ctr) <- \"nalive\"\n  #use obtained number of patients at each cycle to get the same for costs and QALYs\n  costs_cycle_exp <- as.matrix(rowSums(as.matrix(tm_exp*c_exp)[,-3]))\n  colnames(costs_cycle_exp) <- \"costs\"\n  costs_cycle_ctr <- as.matrix(rowSums(as.matrix(tm_ctr*c_ctr)[,-3]))\n  colnames(costs_cycle_ctr) <- \"costs\"\n  QALY_cycle_exp <- matrix(NA, nrow = n_cycle+1, ncol = 3)\n  colnames(QALY_cycle_exp) <- c(\"Well\",\"Sick\",\"Dead\")\n  QALY_cycle_ctr <- matrix(NA, nrow = n_cycle+1, ncol = 3)\n  colnames(QALY_cycle_ctr) <- c(\"Well\",\"Sick\",\"Dead\")\n  u_well_v <- rep(u_well,n_cycle)\n  u_sick_v <- rep(u_sick,n_cycle)\n  u_dead_v <- rep(u_dead,n_cycle)\n  u_M <- cbind(u_well_v,u_sick_v,u_dead_v)\n  QALY_cycle_exp <- as.matrix(rowSums(as.matrix(tm_exp*u_M)[,-3]))\n  colnames(QALY_cycle_exp) <- c(\"QALYs\")\n  QALY_cycle_ctr <- as.matrix(rowSums(as.matrix(tm_ctr*u_M)[,-3]))\n  colnames(QALY_cycle_ctr) <- c(\"QALYs\")\n  #save output\n  res_list_exp[[1]] <- tm_exp\n  res_list_exp[[2]] <- npat_cycle_exp\n  res_list_exp[[3]] <- nailive_cycle_exp\n  res_list_exp[[4]] <- costs_cycle_exp\n  res_list_exp[[5]] <- QALY_cycle_exp\n  res_list_ctr[[1]] <- tm_ctr\n  res_list_ctr[[2]] <- npat_cycle_ctr\n  res_list_ctr[[3]] <- nailive_cycle_ctr\n  res_list_ctr[[4]] <- costs_cycle_ctr\n  res_list_ctr[[5]] <- QALY_cycle_ctr\n  names(res_list_exp)<-c(\"TM\",\"npatients\",\"nalive\",\"costs\",\"QALYs\")\n  names(res_list_ctr)<-c(\"TM\",\"npatients\",\"nalive\",\"costs\",\"QALYs\")\n  res_list[[1]] <- res_list_exp\n  res_list[[2]] <- res_list_ctr\n  names(res_list)<-c(\"Experimental\",\"Control\")\n  return(res_list)\n}\n\n#run the function and get the output\nmm_res <- mm_sim(tm_exp_init = tm_exp_init, tm_ctr_init = tm_ctr_init, tm_exp_update = tm_exp_update,\n       tm_ctr_update = tm_ctr_update, u_well = u_well, u_sick = u_sick, u_dead = u_dead, c_exp = c_exp,\n       c_ctr = c_ctr, n_cycle = n_cycle, n_pat = n_pat)\n```\n:::\n\n\n\nFor example, we can extract information regarding the number of patients associated with each health state at each cycle of the model for both intervention groups:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#experimental\nmm_res$Experimental$npatients\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            Well       Sick     Dead\n [1,] 2200.00000 3675.00000 4125.000\n [2,] 1173.75000 2975.00000 5851.250\n [3,]  676.93750 2195.81250 7127.250\n [4,]  414.41250 1554.41562 8031.172\n [5,]  264.20641 1077.69375 8658.100\n [6,]  172.77757  739.08849 9088.134\n [7,]  114.70433  503.92524 9381.370\n [8,]   76.81321  342.50166 9580.685\n [9,]   51.69103  232.38562 9715.923\n[10,]   34.88024  157.52323 9807.597\n[11,]   23.57227  106.72203 9869.706\n[12,]   15.94362   72.28351 9911.773\n```\n\n\n:::\n\n```{.r .cell-code}\n#control\nmm_res$Control$npatients\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             Well        Sick     Dead\n [1,] 875.0000000 1750.000000 7375.000\n [2,] 393.7500000 1006.250000 8600.000\n [3,] 199.0625000  551.250000 9249.688\n [4,] 104.8906250  297.828125 9597.281\n [5,]  56.0054687  160.245313 9783.749\n [6,]  30.0258984   86.111758 9883.862\n [7,]  16.1176504   46.256766 9937.626\n [8,]   8.6550892   24.844957 9966.500\n [9,]   4.6482680   13.344003 9982.008\n[10,]   2.4964673    7.166868 9990.337\n[11,]   1.3408037    3.849208 9994.810\n[12,]   0.7201217    2.067344 9997.213\n```\n\n\n:::\n:::\n\n\n\n\nor the costs and QALYs accrued at each cycle across the alive patients\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#experimental\nmm_res$Experimental$costs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           costs\n [1,] 560.475000\n [2,] 395.790750\n [3,] 274.060350\n [4,] 187.826203\n [5,] 128.017275\n [6,]  86.992022\n [7,]  59.017262\n [8,]  40.002639\n [9,]  27.100912\n[10,]  18.355292\n[11,]  12.430076\n[12,]   8.416869\n```\n\n\n:::\n\n```{.r .cell-code}\nmm_res$Experimental$QALYs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            QALYs\n [1,] 0.318600000\n [2,] 0.210552500\n [3,] 0.140633625\n [4,] 0.094500800\n [5,] 0.063715850\n [6,] 0.043040190\n [7,] 0.029103948\n [8,] 0.019691497\n [9,] 0.013327325\n[10,] 0.009021588\n[11,] 0.006107518\n[12,] 0.004134943\n```\n\n\n:::\n\n```{.r .cell-code}\n#control\nmm_res$Control$costs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            costs\n [1,] 114.1875000\n [2,]  60.9000000\n [3,]  32.6385937\n [4,]  17.5182656\n [5,]   9.4069090\n [6,]   5.0519880\n [7,]   2.7132871\n [8,]   1.4572520\n [9,]   0.7826638\n[10,]   0.4203551\n[11,]   0.2257655\n[12,]   0.1212548\n```\n\n\n:::\n\n```{.r .cell-code}\nmm_res$Control$QALYs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             QALYs\n [1,] 0.1382500000\n [2,] 0.0709625000\n [3,] 0.0375768750\n [4,] 0.0200945938\n [5,] 0.0107782391\n [6,] 0.0057864904\n [7,] 0.0031074474\n [8,] 0.0016688952\n [9,] 0.0008963250\n[10,] 0.0004813992\n[11,] 0.0002585510\n[12,] 0.0001388633\n```\n\n\n:::\n:::\n\n\n\nfrom which an estimate of the mean costs and QALYs (and the group differences) over the $12$ months period (without discounting) can be obtained by taking the sum across these accrued expected values at each cycle\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#experimental\nmu_c_exp <- sum(mm_res$Experimental$costs)\nmu_e_exp <- sum(mm_res$Experimental$QALYs)\n\n#control\nmu_c_ctr <- sum(mm_res$Control$costs)\nmu_e_ctr <- sum(mm_res$Control$QALYs)\n\nmu_c_diff <- mu_c_exp-mu_c_ctr\nmu_e_diff <- mu_e_exp-mu_e_ctr\n```\n:::\n\n\n\nand form this an estimate of the ICER can be obtained:\n\n$$\n\\text{ICER} = \\frac{1798.4846494 - 245.4238347}{0.9524298-0.2900002} =\\frac{1553.0608148}{0.6624296} = 2344.49\n$$\n\nI hope you enjoyed today's topic as it was quite interesting, at least for me. I always want to learn more about this stuff and rarely have the time do so. By going through the coding, I think things become much easier to understand, especially when these types of models can be quite complex and difficult to grasp by just reading it on a paper. Probably next time I will dive into the uncertainty assessment for these models, which at the moment I neglected due to time constraints. Well, then hope to see you back on my next post to learn how to do that as well (if you are interested). \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}