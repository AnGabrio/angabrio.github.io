<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2016-04-27">
<meta name="description" content="The most popular class of Bayesian iterative methods is called Markov chain Monte Carlo (MCMC), which comprises different algorithms for sampling from a probability distribution. The more steps that are included, the more closely the distribution of the sample matches the actual desired distribution">

<title>Bayesian Iterative Simulation Methods – Andrea Gabrio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/icon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-54989a6d3e0684930921735f132eff69.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Andrea Gabrio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../missing_data.html"> 
<span class="menu-text">Missing Data</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tutorials.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#data-augmentation" id="toc-data-augmentation" class="nav-link active" data-scroll-target="#data-augmentation">Data Augmentation</a>
  <ul class="collapse">
  <li><a href="#bivariate-normal-data-example" id="toc-bivariate-normal-data-example" class="nav-link" data-scroll-target="#bivariate-normal-data-example">Bivariate Normal Data Example</a></li>
  </ul></li>
  <li><a href="#the-gibbs-sampler" id="toc-the-gibbs-sampler" class="nav-link" data-scroll-target="#the-gibbs-sampler">The Gibbs’ Sampler</a></li>
  <li><a href="#assessing-convergence" id="toc-assessing-convergence" class="nav-link" data-scroll-target="#assessing-convergence">Assessing Convergence</a></li>
  <li><a href="#other-simulation-methods" id="toc-other-simulation-methods" class="nav-link" data-scroll-target="#other-simulation-methods">Other Simulation Methods</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Bayesian Iterative Simulation Methods</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Quarto</div>
    <div class="quarto-category">R</div>
    <div class="quarto-category">Academia</div>
    <div class="quarto-category">Missing Data</div>
  </div>
  </div>

<div>
  <div class="description">
    The most popular class of Bayesian iterative methods is called Markov chain Monte Carlo (MCMC), which comprises different algorithms for sampling from a probability distribution. The more steps that are included, the more closely the distribution of the sample matches the actual desired distribution
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 27, 2016</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>A useful alternative approach to <em>Maximum Likelihood</em>(ML) methods, particularly when the sample size is small, is to include a reasonable prior distribution for the parameters and compute the posterior distribution of the parameters of interest. The posterior distribution for a model with ignorable missingness is</p>
<p><span class="math display">\[
p(\theta \mid Y_0, M) \equiv p(\theta \mid Y_0) \propto p(\theta)f(Y_0 \mid \theta),
\]</span></p>
<p>where <span class="math inline">\(p(\theta)\)</span> is the prior and <span class="math inline">\(f(Y_0 \mid \theta)\)</span> is the density of the observed data <span class="math inline">\(Y_0\)</span>. Simulation from the posterior without iteration can be accomplished if the likelihood can be factored into complete data components, while for general patterns of missing data, Bayesian simulation requires iteration.</p>
<section id="data-augmentation" class="level2">
<h2 class="anchored" data-anchor-id="data-augmentation">Data Augmentation</h2>
<p><em>Data Augmentation</em>(<span class="citation" data-cites="tanner1987calculation">Tanner and Wong (<a href="#ref-tanner1987calculation" role="doc-biblioref">1987</a>)</span>), or DA, is an iterative method of simulating the posteiror distribution of <span class="math inline">\(\theta\)</span> that combines features of the <em>Expecation Maximisation</em>(EM) algorithm and <em>Multiple Imputation</em>(MI). Starting with an initial draw <span class="math inline">\(\theta_0\)</span> from an approximation to the posterior, then given the value <span class="math inline">\(\theta_t\)</span> at iteration <span class="math inline">\(t\)</span>:</p>
<ol type="1">
<li><p>Draw <span class="math inline">\(Y_{1,t+1}\)</span> with density <span class="math inline">\(p(Y_1 \mid Y_0, \theta_t)\)</span> (I step).</p></li>
<li><p>Draw <span class="math inline">\(\theta_{t+1}\)</span> with density <span class="math inline">\(p(\theta \mid Y_0, Y_{1,t+1})\)</span> (P step).</p></li>
</ol>
<p>The procedure is motivated by the fact that the distributions in these two steps are often much easier to draw from than either of the posteriors <span class="math inline">\(p(Y_1 \mid Y_0)\)</span> and <span class="math inline">\(p(\theta \mid Y_0)\)</span>, or the joint posterior <span class="math inline">\(p(\theta, Y_1 \mid Y_0)\)</span>. The procedure can be shown to eventually yield a draw from the joint posterior of <span class="math inline">\(Y_1\)</span> and <span class="math inline">\(\theta\)</span> given <span class="math inline">\(Y_0\)</span>, in the sense that as <span class="math inline">\(t\)</span> tends to infinity this sequence converges to a draw from the joint distribution.</p>
<section id="bivariate-normal-data-example" class="level3">
<h3 class="anchored" data-anchor-id="bivariate-normal-data-example">Bivariate Normal Data Example</h3>
<p>Suppose having a sample <span class="math inline">\(y_i=(y_{1i},y_{2i})\)</span> from a Bivariate Normal distribution for <span class="math inline">\(i=1,\ldots,n\)</span> units, with mean vector <span class="math inline">\(\mu=(\mu_1,\mu_2)\)</span> and <span class="math inline">\(2\times2\)</span> covariance matrix <span class="math inline">\(\Sigma\)</span>. Assume that one group of units has <span class="math inline">\(Y_1\)</span> observed and <span class="math inline">\(Y_2\)</span> missing, while a second group of units has both variables observed and a third group of units has <span class="math inline">\(Y_1\)</span> missing and <span class="math inline">\(Y_2\)</span> observed. Under DA methods, each iteration <span class="math inline">\(t\)</span> consists of an I step and a P step. In the first, missing data are replaced with draws from its conditional distribution given the observed data and current values of the parameters (rather then its conditional mean as in the EM algorithm). Because units are conditionally independent given the parameters, each missing <span class="math inline">\(y_{2i}\)</span> is drawn independently as</p>
<p><span class="math display">\[
y_{2i,t+1} \sim N\left(\beta_{20t} + \beta_{21t}y_{1i}, \sigma^2_{2t}  \right),
\]</span></p>
<p>where <span class="math inline">\(\beta_{20t},\beta_{21t}\)</span> and <span class="math inline">\(\sigma^2_{2t}\)</span> are the <span class="math inline">\(t\)</span>-th iterates of the regression parameters of <span class="math inline">\(Y_2\)</span> on <span class="math inline">\(Y_1\)</span>. Analogously, each missing <span class="math inline">\(y_{1i}\)</span> is drawn independently as</p>
<p><span class="math display">\[
y_{1i,t+1} \sim N\left(\beta_{10t} + \beta_{11t}y_{2i}, \sigma^2_{1t}  \right),
\]</span></p>
<p>where <span class="math inline">\(\beta_{10t},\beta_{11t}\)</span> and <span class="math inline">\(\sigma^2_{1t}\)</span> are the <span class="math inline">\(t\)</span>-th iterates of the regression parameters of <span class="math inline">\(Y_1\)</span> on <span class="math inline">\(Y_2\)</span>. In the second step, these drawn values are treated as if they were the observed values and one draw of the bivariate Normal parameters is made from the complete data posterior. In the limit, the draws are from the joint posterior of the missing values and the parameters. Thus, a run of DA generates both a draw from the posterior predictive distribution of <span class="math inline">\(Y_1\)</span> and a draw from the posterior of <span class="math inline">\(\theta\)</span>, and the procedure can be run <span class="math inline">\(D\)</span> times to obtain <span class="math inline">\(D\)</span> iid draws from the joint posterior of <span class="math inline">\(\theta\)</span> and <span class="math inline">\(Y_1\)</span>. Unlike the EM, estimates of the sampling covariance matrix from the filled-in data can be computed without any corrections to the estimated variances because draws from the posterior predictive distribution of the missing values are imputed in the I step of DA, rather than the conditional means as in the E step of EM. The loss of efficiency from imputing draws is limited when the posterior mean from DA is computed over many draws from the posterior.</p>
</section>
</section>
<section id="the-gibbs-sampler" class="level2">
<h2 class="anchored" data-anchor-id="the-gibbs-sampler">The Gibbs’ Sampler</h2>
<p>The <em>Gibbs’s sampler</em> is an iterative simulation method that is designed to yield draws from the joint posterior distribution in the case of a general pattern of missingness and provides a Bayesian analogous to the <em>Expectation Conditonal Maximisation </em>(ECM) algorithm for ML estimation. The Gibbs’ sampler eventually generates a draw from the distribution <span class="math inline">\(p(x_1,\ldots,x_J)\)</span> of a set of <span class="math inline">\(J\)</span> random variables <span class="math inline">\(X_1,\ldots,X_J\)</span> in settings where draws from the joint distribution are hard to compute but draws from the conditional distributions <span class="math inline">\(p(x_j \mid x_1,\ldots,x_{j-1},x_{j+1},\ldots, x_J)\)</span> are relatively easy to compute. Initial values <span class="math inline">\(x_{10},\ldots,x_{J0}\)</span> are chosen in some way and then, given current values of <span class="math inline">\(x_{1t},\ldots,x_{Jt}\)</span> at iteration <span class="math inline">\(t\)</span>, new values are found by drawing from the following sequence of conditional distributions:</p>
<p><span class="math display">\[
x_{1t+1} \sim p\left(x_1 \mid x_{2t},\ldots,x_{Jt} \right),
\]</span></p>
<p><span class="math display">\[
x_{2t+1} \sim p\left(x_2 \mid x_{1t+1},\ldots,x_{Jt} \right),
\]</span></p>
<p>up to</p>
<p><span class="math display">\[
x_{Jt+1} \sim p\left(x_J \mid x_{2t+1},\ldots,x_{J-1t+1} \right).
\]</span></p>
<p>It can be shown that, under general conditions, the sequence of <span class="math inline">\(J\)</span> iterates converges to a draw from the joint posterior of the variables. When <span class="math inline">\(J=2\)</span>, the Gibbs’ sampler is the same as DA if <span class="math inline">\(x_1=Y_1\)</span> and <span class="math inline">\(x_2=\theta\)</span> and the distributions condition on <span class="math inline">\(Y_0\)</span>. We can then obtain a draw from the joint posterior of <span class="math inline">\(Y_1,\theta \mid Y_0\)</span> by applying the Gibbs’ sampler, where at iteration <span class="math inline">\(t\)</span> for the <span class="math inline">\(d\)</span>-th imputed data set:</p>
<p><span class="math display">\[
Y^d_{1t+1} \sim p\left(Y_1 \mid Y_0, \theta^d_{t}\right) \;\;\; \text{and} \;\;\; \theta^d_{t+1} \sim p\left(\theta \mid Y^d_{1t+1}, Y_0\right),
\]</span></p>
<p>such that one run of the sampler converges to a draw from the posterior predictive distribution of <span class="math inline">\(Y_1\)</span> and a draw from the posterior of <span class="math inline">\(\theta\)</span>. The sampler can be run independently <span class="math inline">\(D\)</span> times to generate <span class="math inline">\(D\)</span> iid draws from the approximate joint posterior of <span class="math inline">\(\theta\)</span> and <span class="math inline">\(Y_1\)</span>. The values of <span class="math inline">\(Y_1\)</span> are multiple imputations of the missing values, drawn from their posterior predictive distribution.</p>
</section>
<section id="assessing-convergence" class="level2">
<h2 class="anchored" data-anchor-id="assessing-convergence">Assessing Convergence</h2>
<p>Assessing convergence of the sequence of draws to the target distribution is more difficult than assessing convergence of an EM-type algorithm because there is no single target quantity to monitor like the maximum value of the likelihood. Methods have been proposed to assess convergence of a single sequence (<span class="citation" data-cites="geyer1992practical">Geyer (<a href="#ref-geyer1992practical" role="doc-biblioref">1992</a>)</span>), but a more reliable approach is to simulate <span class="math inline">\(D&gt;1\)</span> sequences with starting values dispersed throughout the parameter space, and the convergence of all quantities of interest can then be monitored by comparing variation between and within simulated sequences, until the “within” variation roughly equals the “between” variation. The idea is that when the distribution of each simulated sequence is close enough to the distribution of all the sequences mixed together, they can all be approximating the target distribution. <span class="citation" data-cites="gelman1992single">Gelman and Rubin (<a href="#ref-gelman1992single" role="doc-biblioref">1992</a>)</span> developed an explicit monitoring statistic based on the following idea. For each scalar estimand <span class="math inline">\(\psi\)</span>, label the draws from <span class="math inline">\(D\)</span> parallel sequences as <span class="math inline">\(\psi^d_{t}\)</span>, for <span class="math inline">\(t=1,\ldots,T\)</span> iterations and <span class="math inline">\(d=1,\ldots,D\)</span> sequences, and compute the between <span class="math inline">\(B\)</span> and within <span class="math inline">\(\bar{V}\)</span> sequence variances as:</p>
<p><span class="math display">\[
B=\frac{T}{D-1}\sum_{d=1}^D(\bar{\psi}_{d.} - \bar{\psi}_{..})^2, \;\;\; \text{and} \;\;\; \bar{V}=\frac{1}{D}\sum_{d=1}^D s^2_{d},
\]</span></p>
<p>where <span class="math inline">\(\bar{\psi}_{d.}=\frac{1}{T}\sum_{t=1}^T \psi_{dt}\)</span>, <span class="math inline">\(\bar{\psi}_{..}=\frac{1}{D}\sum_{d=1}^D \bar{\psi}_{d}\)</span>, and <span class="math inline">\(s^2_{d}=\frac{1}{T-1}\sum_{t=1}^T(\psi_{dt} - \bar{\psi}_{d.})^2\)</span>. We can then estimate the marginal posterior variance of the estimand as</p>
<p><span class="math display">\[
\widehat{Var}(\psi \mid Y_0) = \frac{T-1}{T}\hat{V} + \frac{1}{T} B,
\]</span></p>
<p>which will <em>overestimate</em> the marginal posterior variance assuming the starting distribution is appropriately over-dispersed but is <em>unbiased</em> under stationarity (starting distribution equals the target distribution). For any finte <span class="math inline">\(T\)</span>, the within variance <span class="math inline">\(\hat{V}\)</span> will <em>underestimate</em> the marginal variance because individual sequences have not had time to range over all the target distribution and should have smaller variance then B. In the limit as <span class="math inline">\(T \rightarrow \infty\)</span> the expecation of <span class="math inline">\(\hat{V}\)</span> approaches the marginal variance. These facts suggest monitoring convergence by estimating the factor by which the scale of the current distribution for <span class="math inline">\(\psi\)</span> might be reduced if the simulations were continued. This is the <em>potential scale reduction factor</em> and is estimated by</p>
<p><span class="math display">\[
\sqrt{\hat{R}} = \sqrt{\frac{\widehat{Var}(\psi \mid Y_0)}{\hat{V}}},
\]</span></p>
<p>which declines to 1 as <span class="math inline">\(T \rightarrow \infty\)</span>. When this quantity is high, there is evidence to proceed the simulations further to improve our inference about the target distribution.</p>
</section>
<section id="other-simulation-methods" class="level2">
<h2 class="anchored" data-anchor-id="other-simulation-methods">Other Simulation Methods</h2>
<p>When draws from the sequence of conditional distributions forming the Gibbs’ sampler are not easy to obtain, other simulation approaches are needed. Among these there are the <em>Sequential Imputation</em> (<span class="citation" data-cites="kong1994sequential">Kong, Liu, and Wong (<a href="#ref-kong1994sequential" role="doc-biblioref">1994</a>)</span>), <em>Sampling Imprtance Resampling</em> (<span class="citation" data-cites="gelfand1990sampling">Gelfand and Smith (<a href="#ref-gelfand1990sampling" role="doc-biblioref">1990</a>)</span>), <em>Rejection Sampling</em> (<span class="citation" data-cites="von1951general">Von Neumann et al. (<a href="#ref-von1951general" role="doc-biblioref">1951</a>)</span>). One of these alternatives are the <em>Metropolis-Hastings</em> (<span class="citation" data-cites="metropolis1953equation">Metropolis et al. (<a href="#ref-metropolis1953equation" role="doc-biblioref">1953</a>)</span>) algorithms, of which the Gibbs’ sampler is a particular case, which constitute the so-called <em>Markov Chain Monte Carlo</em> (MCMC) algorithms as the sequence of iterates forms a Markov Chain (<span class="citation" data-cites="gelman2013bayesian">Gelman et al. (<a href="#ref-gelman2013bayesian" role="doc-biblioref">2013</a>)</span>).</p>
</section>
<section id="references" class="level1">




</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-gelfand1990sampling" class="csl-entry" role="listitem">
Gelfand, Alan E, and Adrian FM Smith. 1990. <span>“Sampling-Based Approaches to Calculating Marginal Densities.”</span> <em>Journal of the American Statistical Association</em> 85 (410): 398–409.
</div>
<div id="ref-gelman2013bayesian" class="csl-entry" role="listitem">
Gelman, Andrew, John B Carlin, Hal S Stern, David B Dunson, Aki Vehtari, and Donald B Rubin. 2013. <em>Bayesian Data Analysis</em>. Chapman; Hall/CRC.
</div>
<div id="ref-gelman1992single" class="csl-entry" role="listitem">
Gelman, Andrew, and Donald B Rubin. 1992. <span>“A Single Series from the Gibbs Sampler Provides a False Sense of Security.”</span> <em>Bayesian Statistics</em> 4: 625–31.
</div>
<div id="ref-geyer1992practical" class="csl-entry" role="listitem">
Geyer, Charles J. 1992. <span>“Practical Markov Chain Monte Carlo.”</span> <em>Statistical Science</em>, 473–83.
</div>
<div id="ref-kong1994sequential" class="csl-entry" role="listitem">
Kong, Augustine, Jun S Liu, and Wing Hung Wong. 1994. <span>“Sequential Imputations and Bayesian Missing Data Problems.”</span> <em>Journal of the American Statistical Association</em> 89 (425): 278–88.
</div>
<div id="ref-metropolis1953equation" class="csl-entry" role="listitem">
Metropolis, Nicholas, Arianna W Rosenbluth, Marshall N Rosenbluth, Augusta H Teller, and Edward Teller. 1953. <span>“Equation of State Calculations by Fast Computing Machines.”</span> <em>The Journal of Chemical Physics</em> 21 (6): 1087–92.
</div>
<div id="ref-tanner1987calculation" class="csl-entry" role="listitem">
Tanner, Martin A, and Wing Hung Wong. 1987. <span>“The Calculation of Posterior Distributions by Data Augmentation.”</span> <em>Journal of the American Statistical Association</em> 82 (398): 528–40.
</div>
<div id="ref-von1951general" class="csl-entry" role="listitem">
Von Neumann, John et al. 1951. <span>“The General and Logical Theory of Automata.”</span> <em>1951</em>, 1–41.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024, Andrea Gabrio</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>