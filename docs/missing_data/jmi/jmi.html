<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2016-04-27">
<meta name="description" content="Joint Multiple Imputation (JOMO) commonly assumes that the incomplete variables follow a multivariate normal distribution, often referred to as multivariate normal imputation and, under this assumption, provides rigorous standard errors for the fitted parameters">

<title>Joint Multiple Imputation – Andrea Gabrio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/icon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-54989a6d3e0684930921735f132eff69.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Andrea Gabrio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../missing_data.html"> 
<span class="menu-text">Missing Data</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tutorials.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#rubins-rules" id="toc-rubins-rules" class="nav-link active" data-scroll-target="#rubins-rules">Rubin’s rules</a></li>
  <li><a href="#joint-multiple-imputation" id="toc-joint-multiple-imputation" class="nav-link" data-scroll-target="#joint-multiple-imputation">Joint Multiple Imputation</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Joint Multiple Imputation</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Quarto</div>
    <div class="quarto-category">R</div>
    <div class="quarto-category">Academia</div>
    <div class="quarto-category">Missing Data</div>
  </div>
  </div>

<div>
  <div class="description">
    Joint Multiple Imputation (JOMO) commonly assumes that the incomplete variables follow a multivariate normal distribution, often referred to as multivariate normal imputation and, under this assumption, provides rigorous standard errors for the fitted parameters
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 27, 2016</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><em>Multiple Imputation</em>(MI) refers to the procedure of replacing each missing value by a set of <span class="math inline">\(H\geq 2\)</span> imputed values. These are ordered in the sense that <span class="math inline">\(H\)</span> completed data sets can be created from the sets of imputations, where the first imputed value replaces the missing value in the first completed data set, the second imputed value in the second completed data set, and so on. Next, standard complete data methods are used to analyse each completed data set. When the <span class="math inline">\(H\)</span> sets of imputations are repeated random draws from the predictive distribution of the missing data under a particular model of missingness, the <span class="math inline">\(H\)</span> completed data inferences can be combined to form one inference that properly reflects uncertainty due to missing values under that model. In general, MI procedures can be summarised in three main steps:</p>
<ol type="1">
<li><p>Specify an <strong>imputation model</strong> to generate <span class="math inline">\(H\)</span> imputed values, typically taken as random draws from the predictive distribution of the missing values given the observed values, and create <span class="math inline">\(H\)</span> completed data sets using these imputations and the observed data.</p></li>
<li><p>Analyse each completed data sets using standard complete data methods based on an <strong>analysis model</strong>, and derive <span class="math inline">\(H\)</span> completed data inferences</p></li>
<li><p>Pool together the <span class="math inline">\(H\)</span> completed data inferences into a single inference using standard MI formulas, which ensure that missing data uncertainty is taken into account</p></li>
</ol>
<p>Mi was first proposed by Rubin (<span class="citation" data-cites="rubin1978multiple">Rubin (<a href="#ref-rubin1978multiple" role="doc-biblioref">1978</a>)</span>) and has become more popular over time (<span class="citation" data-cites="rubin1996multiple">Rubin (<a href="#ref-rubin1996multiple" role="doc-biblioref">1996</a>)</span>, <span class="citation" data-cites="schafer2002missing">Schafer and Graham (<a href="#ref-schafer2002missing" role="doc-biblioref">2002</a>)</span>, <span class="citation" data-cites="little2019statistical">Little and Rubin (<a href="#ref-little2019statistical" role="doc-biblioref">2019</a>)</span>), as well as the focus of research for methodological and practical applications in a variety of fields (<span class="citation" data-cites="herzog1983using">Herzog and Rubin (<a href="#ref-herzog1983using" role="doc-biblioref">1983</a>)</span>, <span class="citation" data-cites="rubin1987interval">Rubin and Schenker (<a href="#ref-rubin1987interval" role="doc-biblioref">1987</a>)</span>, <span class="citation" data-cites="schafer1999multiple">Schafer (<a href="#ref-schafer1999multiple" role="doc-biblioref">1999</a>)</span>, <span class="citation" data-cites="carpenter2012multiple">Carpenter and Kenward (<a href="#ref-carpenter2012multiple" role="doc-biblioref">2012</a>)</span>, <span class="citation" data-cites="molenberghs2014handbook">Molenberghs et al. (<a href="#ref-molenberghs2014handbook" role="doc-biblioref">2014</a>)</span>, <span class="citation" data-cites="van2018flexible">Van Buuren (<a href="#ref-van2018flexible" role="doc-biblioref">2018</a>)</span>). MI shares both advantages of <em>Single Imputaiton</em> (SI) methods and solves both disadvantages. Indeed, like SI, MI methods allow the analyst to use familiar complete data methods when analysing the completed data sets. The only disadvantage of MI compared with SI methods is that it takes more time to generate the imputations and analyse the completed data sets. However, <span class="citation" data-cites="rubin2004multiple">Rubin (<a href="#ref-rubin2004multiple" role="doc-biblioref">2004</a>)</span> showed that in order to obtain sufficiently precise estimates, a relatively small number of imputations (typically <span class="math inline">\(10\)</span>) is required. For example, considering a situation with <span class="math inline">\(\lambda=50\%\)</span> missing information and <span class="math inline">\(H=10\)</span> imputations, the efficiency of MI can be shown to be equal to <span class="math inline">\((1+\frac{\lambda}{H})^{-1}=95\%\)</span>. In addition, in today’s computing environments, the work of analysing the completed data sets is quite modest since it involves performing the same task <span class="math inline">\(H\)</span> times. Thus, once a precedure to combine multiple completed data sets is established, the additonal time and effort to handle <span class="math inline">\(50\)</span>, <span class="math inline">\(20\)</span>, or <span class="math inline">\(10\)</span> imputations if often of little consequence.</p>
<p>In the first step of MI, imputations should ideally be created as repeated draws from the <em>posterior predictive distribution</em> of the missing values <span class="math inline">\(y_{mis}\)</span> given the observed values <span class="math inline">\(y_{obs}\)</span>, each repetition being an independent drawing of the parameters and missing values. In practice, implicit imputation models can also be used in place of explicit imputation models (<span class="citation" data-cites="herzog1983using">Herzog and Rubin (<a href="#ref-herzog1983using" role="doc-biblioref">1983</a>)</span>). In the second step, each completed data set is analysed using the same complete data method that would be used in the absence of missingness. Finally, in the last step, standard procedures should be used to combine the compelted data inferences into a single one. The simplest and most popular method for combining the reuslts of <span class="math inline">\(H\)</span> completed data sets is known as <em>Rubin’s rules</em> (<span class="citation" data-cites="rubin2004multiple">Rubin (<a href="#ref-rubin2004multiple" role="doc-biblioref">2004</a>)</span>), which can be explained with a simple example.</p>
<section id="rubins-rules" class="level2">
<h2 class="anchored" data-anchor-id="rubins-rules">Rubin’s rules</h2>
<p>Let <span class="math inline">\(\hat{\theta}_h\)</span> and <span class="math inline">\(V_h\)</span>, for <span class="math inline">\(h=1,\ldots,H\)</span>, be the completed data estimates and sampling variances for a scalar estimand <span class="math inline">\(\theta\)</span>, calculated from <span class="math inline">\(H\)</span> repeated imputations under a given imputation model. Then, according to Rubin’s rules, the combined estimate is simply the average of the <span class="math inline">\(H\)</span> completed data estimates, that is</p>
<p><span class="math display">\[
\bar{\theta}_{H}=\frac{1}{H}\sum_{h=1}^{H}\hat{\theta}_{h}.
\]</span></p>
<p>Because the imputations under MI are conditional draws, under a good imputation model, they provide valid estimates for a wide range of estimands. In addition, the averaging over <span class="math inline">\(H\)</span> imputed data sets increases the efficiency of estimation over that obtained from a single completed data set. The variability associated with the pooled estimate has two components: the <em>average within-imputation variance</em> <span class="math inline">\(\bar{V}_H\)</span> and the <em>between-imputation variance</em> <span class="math inline">\(B_H\)</span>, defined as</p>
<p><span class="math display">\[
\bar{V}_{H}=\frac{1}{H}\sum_{h=1}^{H}V_{h} \;\;\; \text{and} \;\;\; B_{H}=\frac{1}{H-1}\sum_{h=1}^{H}(\hat{\theta}_{h}-\bar{\theta}_{H})^2.
\]</span></p>
<p>The total variability associated with <span class="math inline">\(\bar{\theta}_H\)</span> is the computed as</p>
<p><span class="math display">\[
T_{H}=\bar{V}_H + \frac{H+1}{H}B_{H},
\]</span></p>
<p>where <span class="math inline">\((1+\frac{1}{H})\)</span> is an adjustment factor for finite due to estimating <span class="math inline">\(\theta\)</span> by <span class="math inline">\(\bar{\theta}_H\)</span>. Thus, <span class="math inline">\(\hat{\lambda}_H=(1+\frac{1}{H})\frac{B_H}{T_H}\)</span> is known as the <em>fraction of missing information</em> and is an estimate of the fraction of information about <span class="math inline">\(\theta\)</span> that is missing due to nonresponse. For large sample sizes and scalar quantities like <span class="math inline">\(\theta\)</span>, the reference distribution for interval estimates and significance tests is a <span class="math inline">\(t\)</span> distribution</p>
<p><span class="math display">\[
(\theta - \bar{\theta}_H)\frac{1}{\sqrt{T^2_H}} \sim t_v,
\]</span></p>
<p>where the degrees of freedom <span class="math inline">\(v\)</span> can be approximated with the quantity <span class="math inline">\(v=(H-1)\left(1+\frac{1}{H+1}\frac{\bar{V}_H}{B_H} \right)^2\)</span> (<span class="citation" data-cites="rubin1987interval">Rubin and Schenker (<a href="#ref-rubin1987interval" role="doc-biblioref">1987</a>)</span>). In small data sets, an improved version of <span class="math inline">\(v\)</span> can be obtained as <span class="math inline">\(v^\star=(\frac{1}{v}+\frac{1}{\hat{v}_{obs}})^{-1}\)</span>, where</p>
<p><span class="math display">\[
\hat{v}_{obs}=(1-\hat{\lambda}_{H})\left(\frac{v_{com}+1}{v_{com}+3}\right)v_{com},
\]</span></p>
<p>with <span class="math inline">\(v_{com}\)</span> being the degrees of freedom for appropriate or exact <span class="math inline">\(t\)</span> inferences about <span class="math inline">\(\theta\)</span> when there are no missing values (<span class="citation" data-cites="barnard1999miscellanea">Barnard and Rubin (<a href="#ref-barnard1999miscellanea" role="doc-biblioref">1999</a>)</span>).</p>
<p>The validity of MI rests on how the imputations are created and how that procedure relates to the model used to subsequently analyze the data. Creating MIs often requires special algorithms (<span class="citation" data-cites="schafer1997analysis">Schafer (<a href="#ref-schafer1997analysis" role="doc-biblioref">1997</a>)</span>). In general, they should be drawn from a distribution for the missing data that reflects uncertainty about the parameters of the data model. Recall that with SI methods, it is desirable to impute from the conditional distribution <span class="math inline">\(p(y_{mis}\mid y_{obs},\hat{\theta})\)</span>, where <span class="math inline">\(\hat{\theta}\)</span> is an estimate derived from the observed data. MI extends this approach by first simulating <span class="math inline">\(H\)</span> independent plausible values for the parameters <span class="math inline">\(\theta_1,\ldots,\theta_H\)</span> and then drawing the missing values <span class="math inline">\(y_{mis}^h\)</span> from <span class="math inline">\(p(y_{mis}\mid y_{obs}, \theta_h)\)</span>. Treating parameters as random rather than fixed is an essential part of MI. For this reason, it is natural (but not essential) to motivate MI from the Bayesian perspective, in which the state of knowledge about parameters is represented through a posterior distribution.</p>
</section>
<section id="joint-multiple-imputation" class="level2">
<h2 class="anchored" data-anchor-id="joint-multiple-imputation">Joint Multiple Imputation</h2>
<p>Joint MI starts from the assumption that the data can be described by a multivariate distribution which in many cases, mostly for practical reasons, corresponds to assuming a multivariate Normal distribution. The general idea is that, for a general missing data pattern $ r$, missingness may occur anywhere in the multivariate outcome vector $ y=(y_1,,y_J)$, so that the distribution from which imputations should be drawn varies based on the observed variables in each pattern. For example, given $ r=(0,0,1,1)$, then imputations should be drawn from the bivariate distribution of the missing variables given the observed variables in that pattern, that is from <span class="math inline">\(f(y^{mis}_1,y^{mis}_2 \mid y^{obs}_3, y^{obs}_4, \phi_{12})\)</span>, where <span class="math inline">\(\phi_{12}\)</span> is the probability of being in pattern $ r$ where the first two variables are missing.</p>
<p>Consider the multivariate Normal distribution <span class="math inline">\(y \sim N(\mu,\Sigma)\)</span>, where <span class="math inline">\(\theta=(\mu,\Sigma)\)</span> represent the vector of the parameters of interest which need to be identified. Indeed, for non-monotone missing data, $ $ cannot be generally identified based on the observed data directly $ y^{obs}$, and the typical solution is to iterate imputation and parameter estimation using a general algorithm known as <em>data augmentation</em>(<span class="citation" data-cites="tanner1987calculation">Tanner and Wong (<a href="#ref-tanner1987calculation" role="doc-biblioref">1987</a>)</span>). Following <span class="citation" data-cites="van2018flexible">Van Buuren (<a href="#ref-van2018flexible" role="doc-biblioref">2018</a>)</span>, the general procedure of the algorithm can be summarised as follows:</p>
<ol type="1">
<li><p>Define some plausible starting values for all parameters <span class="math inline">\(\theta_0=(\mu_0,\Sigma_0)\)</span></p></li>
<li><p>At each iteration <span class="math inline">\(t=1,\ldots,T\)</span>, draw <span class="math inline">\(h=1,\ldots,H\)</span> imputations for each missing value from the predictive distribution of the missing data given the observed data and the current value of the parameters at <span class="math inline">\(t-1\)</span>, that is</p></li>
</ol>
<p><span class="math display">\[
\hat{y}^{mis}_{t} \sim p(y^{mis} \mid y^{obs},\theta_{t-1})
\]</span></p>
<ol start="3" type="1">
<li>Re-estimate the parameters <span class="math inline">\(\theta\)</span> using the observed and imputed data at <span class="math inline">\(t\)</span> based on the multivariate Normal model, that is</li>
</ol>
<p><span class="math display">\[
\hat{\theta}_{t} \sim p(\theta \mid y^{obs}, \hat{y}^{mis}_{t})
\]</span></p>
<p>And reiterate the steps 2 and 3 until convergence, where the stopping rule typically consists in imposing that the change in the parameters between iterations <span class="math inline">\(t-1\)</span> and <span class="math inline">\(t\)</span> should be smaller than a predefined “small” threshold <span class="math inline">\(\epsilon\)</span>. <span class="citation" data-cites="schafer1997analysis">Schafer (<a href="#ref-schafer1997analysis" role="doc-biblioref">1997</a>)</span> showed that imputations generated under the multivariate Normal model can be robust to non-normal data, even though it is generally more efficient to transform the data towards normality, especially when the parameters of interest are difficult to estimate, such as quantiles and variances.</p>
<p>The multivariate Normal model is also often applied to categorical data, with different types of specifications that have been proposed in the literature (<span class="citation" data-cites="schafer1997analysis">Schafer (<a href="#ref-schafer1997analysis" role="doc-biblioref">1997</a>)</span>,<span class="citation" data-cites="horton2003potential">Horton, Lipsitz, and Parzen (<a href="#ref-horton2003potential" role="doc-biblioref">2003</a>)</span>,<span class="citation" data-cites="allison2005imputation">Allison (<a href="#ref-allison2005imputation" role="doc-biblioref">2005</a>)</span>,<span class="citation" data-cites="bernaards2007robustness">Bernaards, Belin, and Schafer (<a href="#ref-bernaards2007robustness" role="doc-biblioref">2007</a>)</span>,<span class="citation" data-cites="yucel2008using">Yucel, He, and Zaslavsky (<a href="#ref-yucel2008using" role="doc-biblioref">2008</a>)</span>,<span class="citation" data-cites="demirtas2009rounding">Demirtas (<a href="#ref-demirtas2009rounding" role="doc-biblioref">2009</a>)</span>). For examples, missing data in contingency tables can be imputed using log-linear models (<span class="citation" data-cites="schafer1997analysis">Schafer (<a href="#ref-schafer1997analysis" role="doc-biblioref">1997</a>)</span>); mixed continuous-categorical data can be imputed under the general location model which combines a log-linear and multivariate Normal model (<span class="citation" data-cites="olkin1961multivariate">Olkin, Tate, et al. (<a href="#ref-olkin1961multivariate" role="doc-biblioref">1961</a>)</span>); two-way imputation can be applied to missing test item responses by imputing missing categorical data by conditioning on the row and column sum scores of the multivariate data (<span class="citation" data-cites="van2007two">Van Ginkel et al. (<a href="#ref-van2007two" role="doc-biblioref">2007</a>)</span>).</p>
</section>
<section id="references" class="level1">




</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-allison2005imputation" class="csl-entry" role="listitem">
Allison, Paul D. 2005. <span>“Imputation of Categorical Variables with PROC MI.”</span> <em>SUGI 30 Proceedings</em> 113 (30): 1–14.
</div>
<div id="ref-barnard1999miscellanea" class="csl-entry" role="listitem">
Barnard, John, and Donald B Rubin. 1999. <span>“Miscellanea. Small-Sample Degrees of Freedom with Multiple Imputation.”</span> <em>Biometrika</em> 86 (4): 948–55.
</div>
<div id="ref-bernaards2007robustness" class="csl-entry" role="listitem">
Bernaards, Coen A, Thomas R Belin, and Joseph L Schafer. 2007. <span>“Robustness of a Multivariate Normal Approximation for Imputation of Incomplete Binary Data.”</span> <em>Statistics in Medicine</em> 26 (6): 1368–82.
</div>
<div id="ref-carpenter2012multiple" class="csl-entry" role="listitem">
Carpenter, James, and Michael Kenward. 2012. <em>Multiple Imputation and Its Application</em>. John Wiley &amp; Sons.
</div>
<div id="ref-demirtas2009rounding" class="csl-entry" role="listitem">
Demirtas, Hakan. 2009. <span>“Rounding Strategies for Multiply Imputed Binary Data.”</span> <em>Biometrical Journal: Journal of Mathematical Methods in Biosciences</em> 51 (4): 677–88.
</div>
<div id="ref-herzog1983using" class="csl-entry" role="listitem">
Herzog, Thomas N, and Donald B Rubin. 1983. <span>“Using Multiple Imputations to Handle Nonresponse in Sample Surveys.”</span> <em>Incomplete Data in Sample Surveys</em> 2: 209–45.
</div>
<div id="ref-horton2003potential" class="csl-entry" role="listitem">
Horton, Nicholas J, Stuart R Lipsitz, and Michael Parzen. 2003. <span>“A Potential for Bias When Rounding in Multiple Imputation.”</span> <em>The American Statistician</em> 57 (4): 229–32.
</div>
<div id="ref-little2019statistical" class="csl-entry" role="listitem">
Little, Roderick JA, and Donald B Rubin. 2019. <em>Statistical Analysis with Missing Data</em>. Vol. 793. John Wiley &amp; Sons.
</div>
<div id="ref-molenberghs2014handbook" class="csl-entry" role="listitem">
Molenberghs, Geert, Garrett Fitzmaurice, Michael G Kenward, Anastasios Tsiatis, and Geert Verbeke. 2014. <em>Handbook of Missing Data Methodology</em>. Chapman; Hall/CRC.
</div>
<div id="ref-olkin1961multivariate" class="csl-entry" role="listitem">
Olkin, Ingram, Robert Fleming Tate, et al. 1961. <span>“Multivariate Correlation Models with Mixed Discrete and Continuous Variables.”</span> <em>The Annals of Mathematical Statistics</em> 32 (2): 448–65.
</div>
<div id="ref-rubin1978multiple" class="csl-entry" role="listitem">
Rubin, Donald B. 1978. <span>“Multiple Imputations in Sample Surveys a Phenomenological Bayesian Approach to Nonresponse.”</span> <em>Proceedings of the Survey Research Methods Section of the American Statistical Association</em> 1: 20–34.
</div>
<div id="ref-rubin1996multiple" class="csl-entry" role="listitem">
———. 1996. <span>“Multiple Imputation After 18 Years.”</span> <em>Journal of the American Statistical Association</em> 91 (434): 473–89.
</div>
<div id="ref-rubin2004multiple" class="csl-entry" role="listitem">
———. 2004. <em>Multiple Imputation for Nonresponse in Surveys</em>. John Wiley &amp; Sons.
</div>
<div id="ref-rubin1987interval" class="csl-entry" role="listitem">
Rubin, Donald B, and Nathaniel Schenker. 1987. <span>“Interval Estimation from Multiply Imputed Data: A Case Study Using Census Agriculture Industry Codes.”</span> <em>Journal of Official Statistics</em> 3 (4): 375.
</div>
<div id="ref-schafer1997analysis" class="csl-entry" role="listitem">
Schafer, Joseph L. 1997. <em>Analysis of Incomplete Multivariate Data</em>. Chapman; Hall/CRC.
</div>
<div id="ref-schafer1999multiple" class="csl-entry" role="listitem">
———. 1999. <span>“Multiple Imputation: A Primer.”</span> <em>Statistical Methods in Medical Research</em> 8 (1): 3–15.
</div>
<div id="ref-schafer2002missing" class="csl-entry" role="listitem">
Schafer, Joseph L, and John W Graham. 2002. <span>“Missing Data: Our View of the State of the Art.”</span> <em>Psychological Methods</em> 7 (2): 147.
</div>
<div id="ref-tanner1987calculation" class="csl-entry" role="listitem">
Tanner, Martin A, and Wing Hung Wong. 1987. <span>“The Calculation of Posterior Distributions by Data Augmentation.”</span> <em>Journal of the American Statistical Association</em> 82 (398): 528–40.
</div>
<div id="ref-van2018flexible" class="csl-entry" role="listitem">
Van Buuren, Stef. 2018. <em>Flexible Imputation of Missing Data</em>. Chapman; Hall/CRC.
</div>
<div id="ref-van2007two" class="csl-entry" role="listitem">
Van Ginkel, Joost R, L Andries Van der Ark, Klaas Sijtsma, and Jeroen K Vermunt. 2007. <span>“Two-Way Imputation: A Bayesian Method for Estimating Missing Scores in Tests and Questionnaires, and an Accurate Approximation.”</span> <em>Computational Statistics &amp; Data Analysis</em> 51 (8): 4013–27.
</div>
<div id="ref-yucel2008using" class="csl-entry" role="listitem">
Yucel, Recai M, Yulei He, and Alan M Zaslavsky. 2008. <span>“Using Calibration to Improve Rounding in Imputation.”</span> <em>The American Statistician</em> 62 (2): 125–29.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024, Andrea Gabrio</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>