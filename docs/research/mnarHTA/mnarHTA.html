<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>angabrio.github.io - Nonignorable Missingness Models in Health Technology Assessment</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/icon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">angabrio.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../missing_data.html"> 
<span class="menu-text">Missing Data</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tutorials.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#standard-approach" id="toc-standard-approach" class="nav-link" data-scroll-target="#standard-approach">Standard approach</a></li>
  <li><a href="#longitudinal-model-to-deal-with-missingness" id="toc-longitudinal-model-to-deal-with-missingness" class="nav-link" data-scroll-target="#longitudinal-model-to-deal-with-missingness">Longitudinal model to deal with missingness</a>
  <ul class="collapse">
  <li><a href="#modelling-framework" id="toc-modelling-framework" class="nav-link" data-scroll-target="#modelling-framework">Modelling framework</a></li>
  </ul></li>
  <li><a href="#conlcusions" id="toc-conlcusions" class="nav-link" data-scroll-target="#conlcusions">Conlcusions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Nonignorable Missingness Models in Health Technology Assessment</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Economic evaluation alongside <em>Randomised Clinical Trials</em> (RCTs) is an important and increasingly popular component of the process of technology appraisal. The typical analysis of individual level data involves the comparison of two interventions for which suitable measures of clinical benefits and costs are observed on each patient enrolled in the trial at different time points throughout the follow up. Individual level data from RCTs are almost invariably affected by missingness. The recorded outcome process is often incomplete due to individuals who drop out or are observed intermittently throughout the study, causing some observations to be missing. In most applications, the economic evaluation is performed on the cross-sectional variables, computed using only the data from the individuals who are observed at each time point in the trial (completers), with at most limited sensitivity analysis to missingness assumptions. This, however, is an extremely inefficient approach as the information from the responses of all partially observed subjects is completely lost and it is also likely biased unless the completers are a random sample of the subjects on each arm. The problem of missingness is often embedded within a more complex framework, which makes the modelling task in economic evaluations particularly challenging. Specifically, the effectiveness and cost data typically present a series of complexities that need to be simultaneously addressed to avoid biased results.</p>
<p>Using a recent randomised trial as our motivating example, we present a Bayesian parametric model for conducting inference on a bivariate health economic longitudinal response. We specify our model to account for the different types of complexities affecting the data while accommodating a sensitivity analysis to explore the impact of alternative missingness assumptions on the inferences and on the decision-making process for health technology assessment.</p>
</section>
<section id="standard-approach" class="level1">
<h1>Standard approach</h1>
<p>To perform the economic evaluation, aggregated measures for both utilities and costs are typically derived from the longitudinal responses recorded in the study. QALYs (<span class="math inline">\(e_{it}\)</span>) and total costs (<span class="math inline">\(c_{it}\)</span>) measures are computed as shown in <a href="#eq-ag" class="quarto-xref">Equation&nbsp;1</a>:</p>
<p><span id="eq-ag"><span class="math display">\[
e_{it}=\sum_{j=1}^{J}(u_{ijt}+u_{ij-1t})\frac{\delta_{j}}{2} \;\;\; \text{and} \;\;\;\  c_{it}=\sum_{j=1}^{J}c_{ijt},
\tag{1}\]</span></span></p>
<p>where <span class="math inline">\(t\)</span> denotes the treatment group, while <span class="math inline">\(\delta_{j}=\frac{\text{Time}_{j}-\text{Time}_{j-1}}{\text{Unit of time}}\)</span> is the percentage of the time unit (typically one year) which is covered between time <span class="math inline">\(j-1\)</span> and <span class="math inline">\(j\)</span> in the trial. The economic evaluation is then performed by applying some parametric model <span class="math inline">\(p(e_{it},c_{it}\mid \boldsymbol \theta)\)</span>, indexed by a set of parameters <span class="math inline">\(\boldsymbol \theta\)</span>, to these cross-sectional quantities, typically using linear regression methods to account for the imbalance in some baseline variables between treatments. We note that the term cross-sectional here refers to analyses based on variables derived from the combination of repeated measurements collected at different times over the trial duration and not on data collected at a single point in time. Finally, <a href="#eq-mu" class="quarto-xref">Equation&nbsp;2</a> shows how QALYs and total costs population mean values are derived from the model:</p>
<p><span id="eq-mu"><span class="math display">\[
\mu_{et} = \text{E}\left(e_{it} \mid \boldsymbol \theta\right) \;\;\; \text{and} \;\;\; \mu_{ct} = \text{E}\left(c_{it} \mid \boldsymbol \theta \right).
\tag{2}\]</span></span></p>
<p>The differences in <span class="math inline">\(\mu_{et}\)</span> and <span class="math inline">\(\mu_{ct}\)</span> between the treatment groups represent the quantities of interest in the economic evaluation and are used in assessing the relative cost-effectiveness of the interventions. This modelling approach has the limitation that <span class="math inline">\(\mu_{et}\)</span> and <span class="math inline">\(\mu_{ct}\)</span> are derived based only on the completers in the study and does not assess the robustness of the results to a range of plausible missingness assumptions. The model also fails to account for the different complexities that affect the utility and cost data in the trial: from the correlation between variables to the skewness and the presence of structural values (zero for the costs and one for the utilities) in both outcomes.</p>
</section>
<section id="longitudinal-model-to-deal-with-missingness" class="level1">
<h1>Longitudinal model to deal with missingness</h1>
<p>We propose an alternative approach to deal with a missing bivariate outcome in economic evaluations, while simultaneously allowing for the different complexities that typically affect utility and cost data. Our approach includes a longitudinal model that improves the current practice by taking into account the information from all observed data as well as the time dependence between the responses.</p>
<p>Let <span class="math inline">\(\boldsymbol u_i=(u_{i0},\ldots,u_{iJ})\)</span> and <span class="math inline">\(\boldsymbol c\_i=(c_{i0},\ldots,c_{iJ})\)</span> denote the vectors of utilities and costs that were supposed to be observed for subject <span class="math inline">\(i\)</span> at time <span class="math inline">\(j\)</span> in the study, with <span class="math inline">\(j \in \{0,1,J\}\)</span>. We denote with <span class="math inline">\(\boldsymbol y_{ij}=(u_{ij},c_{ij})\)</span> the bivariate outcome for subject <span class="math inline">\(i\)</span> formed by the utility and cost pair at time <span class="math inline">\(j\)</span>. We group the individuals according to the missingness patterns and denote with <span class="math inline">\(\boldsymbol r_{ij}=(r^u_{ij},r^c_{ij})\)</span> a pair of indicator variables that take value <span class="math inline">\(1\)</span> if the corresponding outcome for subject <span class="math inline">\(i\)</span> at time <span class="math inline">\(j\)</span> is observed and <span class="math inline">\(0\)</span> otherwise. We denote with <span class="math inline">\(\boldsymbol r_i = (\boldsymbol r_{i0}, \ldots, \boldsymbol r_{iJ})\)</span> the missingness pattern to which subject <span class="math inline">\(i\)</span> belongs, where each pattern is associated with different values for <span class="math inline">\(\boldsymbol r_{ij}\)</span>.</p>
<p><a href="#eq-model" class="quarto-xref">Equation&nbsp;3</a> represents our modelling strategy and factors the joint distribution for the response and missingness as:</p>
<p><span id="eq-model"><span class="math display">\[
p(\boldsymbol y, \boldsymbol r \mid \boldsymbol \omega) = p(\boldsymbol y^{\boldsymbol r}_{obs}, \boldsymbol r \mid  \boldsymbol \omega)p(\boldsymbol y^{\boldsymbol r}_{mis} \mid \boldsymbol y^{\boldsymbol r}_{obs}, \boldsymbol r, \boldsymbol \omega)
\tag{3}\]</span></span></p>
<p>where <span class="math inline">\(\boldsymbol y^{\boldsymbol r}_{obs}\)</span> and <span class="math inline">\(\boldsymbol y^{\boldsymbol r}_{mis}\)</span> indicate the observed and missing responses within pattern <span class="math inline">\(\boldsymbol r\)</span>, respectively. This is the extrapolation <em>factorisation</em> and factors the joint into two components, of which the extrapolation <em>distribution</em> <span class="math inline">\(p(\boldsymbol y^{\boldsymbol r}_{mis} \mid \boldsymbol y^{\boldsymbol r}_{obs}, \boldsymbol r, \boldsymbol \omega)\)</span> remains unidentified by the data in the absence of unverifiable assumptions about the full data.</p>
<p>To specify the observed data distribution <span class="math inline">\(p(\boldsymbol y^{\boldsymbol r}_{obs}, \boldsymbol r \mid  \boldsymbol \omega)\)</span> we use a working model <span class="math inline">\(p^{\star}\)</span> for the joint distribution of the response and missingness. Essentially, the idea behind <a href="#eq-working" class="quarto-xref">Equation&nbsp;4</a> is to use the working model <span class="math inline">\(p^{\star}(\boldsymbol y, \boldsymbol{r} \mid  \boldsymbol \omega)\)</span> to draw inferences about the distribution of the observed data <span class="math inline">\(p(\boldsymbol y^{\boldsymbol r}_{obs}, \boldsymbol r \mid \boldsymbol \omega)\)</span> by integrating out the missing responses:</p>
<p><span id="eq-working"><span class="math display">\[
p(\boldsymbol y^{\boldsymbol r}\_{obs}, \boldsymbol r \mid \boldsymbol \omega) = \int p^{\star}(\boldsymbol y, \boldsymbol{r} \mid  \boldsymbol \omega)d \boldsymbol y^{\boldsymbol r}\_{mis}.
\tag{4}\]</span></span></p>
<p>This approach avoids direct specification of the joint distribution of the observed and missing data <span class="math inline">\(p(\boldsymbol y, \boldsymbol r\mid \boldsymbol \omega)\)</span>, which has the undesirable consequence of identifying the extrapolation distribution with assumptions that are difficult to check. Indeed, since we use <span class="math inline">\(p^{\star}(\boldsymbol y, \boldsymbol r \mid  \boldsymbol \omega)\)</span> only to obtain a model for <span class="math inline">\(p(\boldsymbol y^{\boldsymbol r}_{obs}, \boldsymbol r \mid  \boldsymbol \omega)\)</span> and not as a basis for inference, the extrapolation distribution is left unidentified. Any inference depending on the observed data distribution may be obtained using the working model as the true model, with the advantage that it is often easier to specify a model for the the full data <span class="math inline">\(p(\boldsymbol y,\boldsymbol r)\)</span> compared with a model for the observed data <span class="math inline">\(p(\boldsymbol y^{\boldsymbol r}_{obs},\boldsymbol r)\)</span>.</p>
<p>We specify <span class="math inline">\(p^{\star}\)</span> using a pattern mixture approach, factoring the joint <span class="math inline">\(p(\boldsymbol y,\boldsymbol r \mid \boldsymbol \omega)\)</span> as the product between the marginal distribution of the missingness patterns <span class="math inline">\(p(\boldsymbol r\mid \boldsymbol \psi)\)</span> and the distribution of the response conditional on the patterns <span class="math inline">\(p(\boldsymbol y\mid \boldsymbol r,\boldsymbol \theta)\)</span>, respectively indexed by the distinct parameter vectors <span class="math inline">\(\boldsymbol \psi\)</span> and <span class="math inline">\(\boldsymbol \theta\)</span>. If missingness is monotone it is possible to summarise the patterns by dropout time and directly model the dropout process. Unfortunately, as it often occurs in trial-based health economic data, missingness in the case study is mostly nonmonotone and the sparsity of the data in most patterns makes it not feasible to fit the response model within each pattern, with the exception of the completers (<span class="math inline">\(\boldsymbol r = \boldsymbol 1\)</span>). Thus, we decided to collapse together all the non-completers patterns (<span class="math inline">\(\boldsymbol r \neq \boldsymbol 1\)</span>) and fit the model separately to this aggregated pattern and to the completers. The joint distribution has three components. The first is given by the model for the patterns and the model for the completers (<span class="math inline">\(\boldsymbol r = \boldsymbol 1\)</span>), where no missingness occurs. The second component is a model for the observed data in the collapsed patterns <span class="math inline">\(\boldsymbol r \neq \boldsymbol 1\)</span> that, together with the first component, form the observed data distribution. The last component is the extrapolation distribution.</p>
<p>Because the targeted quantities of interest can be derived based on the marginal utility and cost means at each time <span class="math inline">\(j\)</span>, in our analysis we do not require the full identification of <span class="math inline">\(p(\boldsymbol y^{\boldsymbol r}_{mis} \mid \boldsymbol y^{\boldsymbol r}_{obs},  \boldsymbol r,\boldsymbol \xi)\)</span>. Instead, we only partially identify the extrapolation distribution using <em>partial identifying restrictions</em>. Specifically, we only require the identification of the marginal means for the missing responses in each pattern. We identify the marginal mean of <span class="math inline">\(\boldsymbol y^{\boldsymbol r}_{mis}\)</span> using the observed values, averaged across <span class="math inline">\(\boldsymbol r^\prime \neq \boldsymbol 1\)</span>, and some <em>sensitivity parameters</em> <span class="math inline">\(\boldsymbol \Delta = (\Delta_u,\Delta_c)\)</span>. Therefore, we compute the marginal means by averaging only across the observed components in pattern <span class="math inline">\({\boldsymbol r}^\prime\)</span> and ignore the components that are missing.</p>
<p>We start by setting a benchmark assumption with <span class="math inline">\(\boldsymbol \Delta = \boldsymbol 0\)</span>, and then explore the sensitivity of the results to alternative scenarios by using different prior distributions on <span class="math inline">\(\boldsymbol \Delta\)</span>, calibrated on the observed data. This provides a convenient benchmark scenario from which departures can be explored using alternative informative priors on <span class="math inline">\(\boldsymbol \Delta\)</span>. Once the working model has been fitted to the observed data and the extrapolation distribution has been identified, the overall marginal mean for the response model can be computed by marginalising over <span class="math inline">\(\boldsymbol r\)</span>, i.e.&nbsp;<span class="math inline">\(\text{E}\left[\boldsymbol Y\right] = \sum_{\boldsymbol r} p(\boldsymbol r)\text{E}\left[\boldsymbol Y \mid \boldsymbol r \right]\)</span>.</p>
<section id="modelling-framework" class="level2">
<h2 class="anchored" data-anchor-id="modelling-framework">Modelling framework</h2>
<p>The distribution of the observed responses <span class="math inline">\(\boldsymbol y_{ijt}=(u_{ijv},c_{ijt})\)</span> is specified in terms of a model for the utility and cost variables at time <span class="math inline">\(j=\{0,1,2\}\)</span>, which are jointly modelled without using a multilevel approach and separately by treatment group. In particular, the joint distribution for <span class="math inline">\(\boldsymbol y_{ijt}\)</span> is specified as a series of conditional distributions that capture the dependence between utilities and costs as well as the time dependence.</p>
<p>Following the recommendations from the published literature, we account for the skewness using Beta and Log-Normal distributions for the utilities and costs, respectively. Since the Beta distribution does not allow for negative values, we scaled the utilities on <span class="math inline">\([0,1]\)</span> through the transformation <span class="math inline">\(u^{\star}_{ij}=\frac{u_{ij}-\text{min}(\boldsymbol u_{j})}{\text{max}(\boldsymbol u_{j})-\text{min}(\boldsymbol u_{j})}\)</span>, and fit the model to these transformed variables. To account for the structural values <span class="math inline">\(u_{ij} = 1\)</span> and <span class="math inline">\(c_{ij} = 0\)</span> we use a hurdle approach by including in the model the indicator variables <span class="math inline">\(d^u_{ij}:=\mathbb{I}(u_{ij}=1)\)</span> and <span class="math inline">\(d^c_{ij}:=\mathbb{I}(c_{ij}=0)\)</span>, which take value <span class="math inline">\(1\)</span> if subject <span class="math inline">\(i\)</span> is associated with a structural value at time <span class="math inline">\(j\)</span> and 0 otherwise. The probabilities of observing these values, as well as the mean of each variable, are then modelled conditionally on other variables via linear regressions defined on the logit or log scale. Specifically, at time <span class="math inline">\(j=1,2\)</span>, the probability of observing a zero and the mean costs are modelled conditionally on the utilities and costs at the previous times, while the probability of observing a one and the mean utilities are modelled conditionally on the current costs (also at <span class="math inline">\(j=0\)</span>) and the utilities at the previous times (only at <span class="math inline">\(j=\{1,2\}\)</span>). The model is summarised by <a href="#fig-pmm" class="quarto-xref">Figure&nbsp;1</a>:</p>
<div id="fig-pmm" class="quarto-figure quarto-figure-center quarto-float anchored" width="60%" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pmm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="missing_model.jpg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pmm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Longitudinal model for missingness.
</figcaption>
</figure>
</div>
<p>We use partial identifying restrictions to link the observed data distribution <span class="math inline">\(p(\boldsymbol y_{obs},\boldsymbol r)\)</span> to the extrapolation distribution <span class="math inline">\(p(\boldsymbol y_{mis} \mid \boldsymbol y_{obs},\boldsymbol r)\)</span> and consider interpretable deviations from a benchmark scenario to assess how inferences are driven by our assumptions. Specifically, we identify the marginal mean of the missing responses in each pattern <span class="math inline">\(\boldsymbol y^{\boldsymbol r}_{mis}\)</span> by averaging across the corresponding components that are observed and add the sensitivity parameters <span class="math inline">\(\boldsymbol \Delta_j\)</span>.</p>
<p>We define <span class="math inline">\(\boldsymbol \Delta_j=(\Delta_{c_{j}},\Delta_{u_{j}})\)</span> to be time-specific location shifts at the marginal mean in each pattern and set <span class="math inline">\(\boldsymbol \Delta_j = \boldsymbol 0\)</span> as the benchmark scenario. We then explore departures from this benchmark using alternative priors on <span class="math inline">\(\boldsymbol \Delta_j\)</span>, which are calibrated using the observed standard deviations for costs and utilities at each time <span class="math inline">\(j\)</span> to define the amplitude of the departures from <span class="math inline">\(\boldsymbol \Delta_j=\boldsymbol 0\)</span>.</p>
</section>
</section>
<section id="conlcusions" class="level1">
<h1>Conlcusions</h1>
<p>Missingness represents a threat to economic evaluations as, when dealing with partially-observed data, any analysis makes assumptions about the missing values that cannot be verified from the data at hand. Trial-based analyses are typically conducted on cross-sectional quantities, e.g.&nbsp;QALYs and total costs, which are derived based only on the observed data from the completers in the study. This is an inefficient approach which may discard a substantial proportion of the sample, especially when there is a relatively large number of time points, where individuals are more likely to have some missing value or to drop out from the study. In addition, when there are systematic differences between the responses of the completers and non-completers, which is typically the case when dealing with self-reported outcomes in trial-based analyses, the results based only on the former may be biased and mislead the final assessment. A further concern is that routine analyses typically rely on standard models that ignore or at best fail to properly account for potentially important features in the data such as correlation, skewness, and the presence of structural values.</p>
<p>Our framework represents a considerable step forward for the handling of missingness in economic evaluations compared with the current practice, which typically relies on methods that assume an ignorable MAR and rarely conducts sensitivity analysis to MNAR departures. Nevertheless, further improvements are certainly possible. For example, a potential area for future work is to increase the flexibility of our approach through a semi-parametric or nonparametric specification for the observed data distribution, which would allow a weakening of the model assumptions and likely further improve the fit of the model to the observed data and address sparse patterns in an automated way. As for the extrapolation distribution, alternative identifying restrictions that introduce the sensitivity parameters via the conditional mean (rather than the marginal mean) could be considered, and their impact on the conclusions assessed in a sensitivity analysis.</p>
<p><span style="text-align: center; font-size: 2rem"><a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12522"><i class="fa-solid fa-file-pdf" aria-label="file-pdf"></i></a> &nbsp; <a href="https://github.com/AnGabrio/Talks/blob/master/Longitudinal%20Model/poster_v2.pdf"><i class="fa-solid fa-image" aria-label="image"></i></a> &nbsp; <a href="https://github.com/AnGabrio/Talks/blob/master/Longitudinal%20Model/pres_ictmc_v2.pdf"><i class="fa-solid fa-file-powerpoint" aria-label="file-powerpoint"></i></a> &nbsp; <a href="https://github.com/AnGabrio/Code/tree/master/longitudinal%20model"><i class="fa-solid fa-code" aria-label="code"></i></a></span></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024, Andrea Gabrio</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>